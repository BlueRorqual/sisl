

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>phtncSileTBtrans &mdash; sisl |release| documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="sisl |release| documentation" href="../index.html"/>
        <link rel="up" title="Input/Output (sisl.io)" href="sisl.io.html"/>
        <link rel="next" title="phtsencSileTBtrans" href="sisl.io.tbtrans.phtsencSileTBtrans.html"/>
        <link rel="prev" title="tbtavncSileTBtrans" href="sisl.io.tbtrans.tbtavncSileTBtrans.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> sisl
          

          
          </a>

          
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../other.html">Other resources</a></li>
</ul>
<p class="caption"><span class="caption-text">Publications</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cite.html">Citing sisl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../publications.html">Publications using sisl</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scripts/scripts.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rst/files.html">File formats</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference documentation</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../api.html">API documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="sisl.html">sisl (<code class="docutils literal"><span class="pre">sisl</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.geom.html">Common geometries (<code class="docutils literal"><span class="pre">sisl.geom</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.physics.html">Physical objects (<code class="docutils literal"><span class="pre">sisl.physics</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.shape.html">Shapes</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="sisl.io.html">Input/Output (<code class="docutils literal"><span class="pre">sisl.io</span></code>)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="sisl.io.html#basic-io-classes">Basic IO classes</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="sisl.io.html#external-code-in-out-put-supported">External code in/out put supported</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="sisl.io.html#generic-files">Generic files</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.io.html#bigdft-sisl-io-bigdft">BigDFT (<code class="docutils literal"><span class="pre">sisl.io.bigdft</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.io.html#gulp-sisl-io-gulp">GULP (<code class="docutils literal"><span class="pre">sisl.io.gulp</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.io.html#scaleup-sisl-io-scaleup">ScaleUp (<code class="docutils literal"><span class="pre">sisl.io.scaleup</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.io.html#siesta-sisl-io-siesta">Siesta (<code class="docutils literal"><span class="pre">sisl.io.siesta</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.io.html#transiesta-sisl-io-siesta">TranSiesta (<code class="docutils literal"><span class="pre">sisl.io.siesta</span></code>)</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="sisl.io.html#tbtrans-sisl-io-tbtrans">TBtrans (<code class="docutils literal"><span class="pre">sisl.io.tbtrans</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.io.html#vasp-sisl-io-vasp">VASP (<code class="docutils literal"><span class="pre">sisl.io.vasp</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.io.html#wannier90-sisl-io-wannier90">Wannier90 (<code class="docutils literal"><span class="pre">sisl.io.wannier90</span></code>)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="sisl.linalg.html">Linear algebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.unit.html">Unit conversion (<code class="docutils literal"><span class="pre">sisl.unit</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.utils.html">Utility routines (<code class="docutils literal"><span class="pre">sisl.utils</span></code>)</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">sisl</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../api.html">API documentation</a> &raquo;</li>
        
          <li><a href="sisl.io.html">Input/Output (<code class="docutils literal"><span class="pre">sisl.io</span></code>)</a> &raquo;</li>
        
      <li>phtncSileTBtrans</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api-generated/sisl.io.tbtrans.phtncSileTBtrans.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

/* nice headers on first paragraph of info/warning boxes */
.admonition .first {
    margin: -12px;
    padding: 6px 12px;
    margin-bottom: 12px;
    color: #fff;
    line-height: 1;
    display: block;
}
.admonition.warning .first {
    background: #f0b37e;
}
.admonition.note .first {
    background: #6ab0de;
}
.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}
</style>
<div class="section" id="phtncsiletbtrans">
<h1>phtncSileTBtrans<a class="headerlink" href="#phtncsiletbtrans" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="sisl.io.tbtrans.phtncSileTBtrans">
<em class="property">class </em><code class="descclassname">sisl.io.tbtrans.</code><code class="descname">phtncSileTBtrans</code><span class="sig-paren">(</span><em>filename</em>, <em>mode='r'</em>, <em>lvl=0</em>, <em>access=1</em>, <em>_open=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/io/tbtrans/tbt.html#phtncSileTBtrans"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans" title="Permalink to this definition">¶</a></dt>
<dd><p>PHtrans file object</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.ADOS" title="sisl.io.tbtrans.phtncSileTBtrans.ADOS"><code class="xref py py-obj docutils literal"><span class="pre">ADOS</span></code></a>([elec,&nbsp;E,&nbsp;kavg,&nbsp;atom,&nbsp;orbital,&nbsp;sum,&nbsp;norm])</td>
<td>Spectral density of states (DOS) (1/eV).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.Adensity_matrix" title="sisl.io.tbtrans.phtncSileTBtrans.Adensity_matrix"><code class="xref py py-obj docutils literal"><span class="pre">Adensity_matrix</span></code></a>(elec,&nbsp;E[,&nbsp;kavg,&nbsp;isc,&nbsp;geometry])</td>
<td>Spectral function density matrix at energy <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.E" title="sisl.io.tbtrans.phtncSileTBtrans.E"><code class="xref py py-obj docutils literal"><span class="pre">E</span></code></a> (1/eV)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.BDOS" title="sisl.io.tbtrans.phtncSileTBtrans.BDOS"><code class="xref py py-obj docutils literal"><span class="pre">BDOS</span></code></a>([elec,&nbsp;E,&nbsp;kavg,&nbsp;sum,&nbsp;norm])</td>
<td>Bulk density of states (DOS) (1/eV).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.DOS" title="sisl.io.tbtrans.phtncSileTBtrans.DOS"><code class="xref py py-obj docutils literal"><span class="pre">DOS</span></code></a>([E,&nbsp;kavg,&nbsp;atom,&nbsp;orbital,&nbsp;sum,&nbsp;norm])</td>
<td>Green function density of states (DOS) (1/eV).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.Eindex" title="sisl.io.tbtrans.phtncSileTBtrans.Eindex"><code class="xref py py-obj docutils literal"><span class="pre">Eindex</span></code></a>(E)</td>
<td>Return the closest energy index corresponding to the energy <code class="docutils literal"><span class="pre">E</span></code></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">__init__</span></code>(filename[,&nbsp;mode,&nbsp;lvl,&nbsp;access,&nbsp;_open])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.a2p" title="sisl.io.tbtrans.phtncSileTBtrans.a2p"><code class="xref py py-obj docutils literal"><span class="pre">a2p</span></code></a>(atom)</td>
<td>Return the pivoting orbital indices (0-based) for the atoms</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_ACOHP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_ACOHP"><code class="xref py py-obj docutils literal"><span class="pre">atom_ACOHP</span></code></a>(elec,&nbsp;E[,&nbsp;kavg,&nbsp;isc,&nbsp;uc])</td>
<td>Atomic COHP curve of the spectral function</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_ACOOP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_ACOOP"><code class="xref py py-obj docutils literal"><span class="pre">atom_ACOOP</span></code></a>(elec,&nbsp;E[,&nbsp;kavg,&nbsp;isc,&nbsp;uc])</td>
<td>Atomic COOP curve of the spectral function</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COHP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COHP"><code class="xref py py-obj docutils literal"><span class="pre">atom_COHP</span></code></a>(E[,&nbsp;kavg,&nbsp;isc,&nbsp;uc])</td>
<td>Atomic COHP curve of the Green function</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COHP_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COHP_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">atom_COHP_from_orbital</span></code></a>(COHP[,&nbsp;uc])</td>
<td>Calculate the atomic COHP curve from the orbital COHP</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COOP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COOP"><code class="xref py py-obj docutils literal"><span class="pre">atom_COOP</span></code></a>(E[,&nbsp;kavg,&nbsp;isc,&nbsp;uc])</td>
<td>Atomic COOP curve of the Green function</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COOP_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COOP_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">atom_COOP_from_orbital</span></code></a>(COOP[,&nbsp;uc])</td>
<td>Calculate the atomic COOP curve from the orbital COOP</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_current" title="sisl.io.tbtrans.phtncSileTBtrans.atom_current"><code class="xref py py-obj docutils literal"><span class="pre">atom_current</span></code></a>(elec,&nbsp;E[,&nbsp;kavg,&nbsp;activity])</td>
<td>Atomic current of atoms</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_current_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.atom_current_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">atom_current_from_orbital</span></code></a>(Jij[,&nbsp;activity])</td>
<td>Atomic current of atoms by passing the orbital current</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.bond_current" title="sisl.io.tbtrans.phtncSileTBtrans.bond_current"><code class="xref py py-obj docutils literal"><span class="pre">bond_current</span></code></a>(elec,&nbsp;E[,&nbsp;kavg,&nbsp;isc,&nbsp;only,&nbsp;uc])</td>
<td>Bond-current between atoms (sum of orbital currents)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.bond_current_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.bond_current_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">bond_current_from_orbital</span></code></a>(Jij[,&nbsp;only,&nbsp;uc])</td>
<td>Bond-current between atoms (sum of orbital currents) from an external orbital current</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.btd" title="sisl.io.tbtrans.phtncSileTBtrans.btd"><code class="xref py py-obj docutils literal"><span class="pre">btd</span></code></a>([elec])</td>
<td>Block-sizes for the BTD method</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.chemical_potential" title="sisl.io.tbtrans.phtncSileTBtrans.chemical_potential"><code class="xref py py-obj docutils literal"><span class="pre">chemical_potential</span></code></a>(elec)</td>
<td>Return the chemical potential associated with the electrode <em class="xref py py-obj">elec</em></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.close" title="sisl.io.tbtrans.phtncSileTBtrans.close"><code class="xref py py-obj docutils literal"><span class="pre">close</span></code></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.current" title="sisl.io.tbtrans.phtncSileTBtrans.current"><code class="xref py py-obj docutils literal"><span class="pre">current</span></code></a>([elec_from,&nbsp;elec_to,&nbsp;kavg])</td>
<td>Current from <em class="xref py py-obj">from</em> to <em class="xref py py-obj">to</em> using the k-weights and energy spacings in the file.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.current_parameter" title="sisl.io.tbtrans.phtncSileTBtrans.current_parameter"><code class="xref py py-obj docutils literal"><span class="pre">current_parameter</span></code></a>(elec_from,&nbsp;mu_from,&nbsp;…[,&nbsp;…])</td>
<td>Current from <em class="xref py py-obj">from</em> to <em class="xref py py-obj">to</em> using the k-weights and energy spacings in the file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.density_matrix" title="sisl.io.tbtrans.phtncSileTBtrans.density_matrix"><code class="xref py py-obj docutils literal"><span class="pre">density_matrix</span></code></a>(E[,&nbsp;kavg,&nbsp;isc,&nbsp;geometry])</td>
<td>Density matrix from the Green function at energy <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.E" title="sisl.io.tbtrans.phtncSileTBtrans.E"><code class="xref py py-obj docutils literal"><span class="pre">E</span></code></a> (1/eV)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.electronic_temperature" title="sisl.io.tbtrans.phtncSileTBtrans.electronic_temperature"><code class="xref py py-obj docutils literal"><span class="pre">electronic_temperature</span></code></a>(elec)</td>
<td>Return temperature of the electrode electronic distribution in Kelvin</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.eta" title="sisl.io.tbtrans.phtncSileTBtrans.eta"><code class="xref py py-obj docutils literal"><span class="pre">eta</span></code></a>([elec])</td>
<td>The imaginary part used when calculating the self-energies in eV (or for the device</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.exist" title="sisl.io.tbtrans.phtncSileTBtrans.exist"><code class="xref py py-obj docutils literal"><span class="pre">exist</span></code></a>()</td>
<td>Query whether the file exists</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.fano" title="sisl.io.tbtrans.phtncSileTBtrans.fano"><code class="xref py py-obj docutils literal"><span class="pre">fano</span></code></a>([elec_from,&nbsp;elec_to,&nbsp;kavg])</td>
<td>The Fano-factor for the calculation (requires calculated transmission eigenvalues)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.info" title="sisl.io.tbtrans.phtncSileTBtrans.info"><code class="xref py py-obj docutils literal"><span class="pre">info</span></code></a>([elec])</td>
<td>Information about the calculated quantities available for extracting in this file</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.iter" title="sisl.io.tbtrans.phtncSileTBtrans.iter"><code class="xref py py-obj docutils literal"><span class="pre">iter</span></code></a>([group,&nbsp;dimension,&nbsp;variable,&nbsp;levels,&nbsp;root])</td>
<td>Iterator on all groups, variables and dimensions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.kT" title="sisl.io.tbtrans.phtncSileTBtrans.kT"><code class="xref py py-obj docutils literal"><span class="pre">kT</span></code></a>(elec)</td>
<td>Return temperature of the electrode electronic distribution in eV</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.kindex" title="sisl.io.tbtrans.phtncSileTBtrans.kindex"><code class="xref py py-obj docutils literal"><span class="pre">kindex</span></code></a>(k)</td>
<td>Return the index of the k-point that is closests to the queried k-point (in reduced coordinates)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.mu" title="sisl.io.tbtrans.phtncSileTBtrans.mu"><code class="xref py py-obj docutils literal"><span class="pre">mu</span></code></a>(elec)</td>
<td>Return the chemical potential associated with the electrode <em class="xref py py-obj">elec</em></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.n_btd" title="sisl.io.tbtrans.phtncSileTBtrans.n_btd"><code class="xref py py-obj docutils literal"><span class="pre">n_btd</span></code></a>([elec])</td>
<td>Number of blocks in the BTD partioning</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.norm" title="sisl.io.tbtrans.phtncSileTBtrans.norm"><code class="xref py py-obj docutils literal"><span class="pre">norm</span></code></a>([atom,&nbsp;orbital,&nbsp;norm])</td>
<td>Normalization factor depending on the input</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.o2p" title="sisl.io.tbtrans.phtncSileTBtrans.o2p"><code class="xref py py-obj docutils literal"><span class="pre">o2p</span></code></a>(orbital)</td>
<td>Return the pivoting indices (0-based) for the orbitals</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOHP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOHP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_ACOHP</span></code></a>(elec,&nbsp;E[,&nbsp;kavg,&nbsp;isc])</td>
<td>Orbital resolved COHP analysis of the spectral function</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOOP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOOP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_ACOOP</span></code></a>(elec,&nbsp;E[,&nbsp;kavg,&nbsp;isc])</td>
<td>Orbital COOP analysis of the spectral function</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_COHP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_COHP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_COHP</span></code></a>(E[,&nbsp;kavg,&nbsp;isc])</td>
<td>Orbital resolved COHP analysis of the Green function</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_COOP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_COOP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_COOP</span></code></a>(E[,&nbsp;kavg,&nbsp;isc])</td>
<td>Orbital COOP analysis of the Green function</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_current" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_current"><code class="xref py py-obj docutils literal"><span class="pre">orbital_current</span></code></a>(elec,&nbsp;E[,&nbsp;kavg,&nbsp;isc,&nbsp;only])</td>
<td>Orbital current originating from <em class="xref py py-obj">elec</em> as a sparse matrix</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.pivot" title="sisl.io.tbtrans.phtncSileTBtrans.pivot"><code class="xref py py-obj docutils literal"><span class="pre">pivot</span></code></a>([in_device,&nbsp;sort])</td>
<td>Pivoting orbitals for the full system</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.read" title="sisl.io.tbtrans.phtncSileTBtrans.read"><code class="xref py py-obj docutils literal"><span class="pre">read</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Generic read method which should be overloaded in child-classes</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.read_data" title="sisl.io.tbtrans.phtncSileTBtrans.read_data"><code class="xref py py-obj docutils literal"><span class="pre">read_data</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Read specific type of data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.read_geometry" title="sisl.io.tbtrans.phtncSileTBtrans.read_geometry"><code class="xref py py-obj docutils literal"><span class="pre">read_geometry</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Returns <em class="xref py py-obj">Geometry</em> object from this file</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.read_supercell" title="sisl.io.tbtrans.phtncSileTBtrans.read_supercell"><code class="xref py py-obj docutils literal"><span class="pre">read_supercell</span></code></a>()</td>
<td>Returns <em class="xref py py-obj">SuperCell</em> object from this file</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.shot_noise" title="sisl.io.tbtrans.phtncSileTBtrans.shot_noise"><code class="xref py py-obj docutils literal"><span class="pre">shot_noise</span></code></a>([elec_from,&nbsp;elec_to,&nbsp;classical,&nbsp;kavg])</td>
<td>Shot-noise term <em class="xref py py-obj">from</em> to <em class="xref py py-obj">to</em> using the k-weights and energy spacings in the file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.transmission" title="sisl.io.tbtrans.phtncSileTBtrans.transmission"><code class="xref py py-obj docutils literal"><span class="pre">transmission</span></code></a>([elec_from,&nbsp;elec_to,&nbsp;kavg])</td>
<td>Transmission from <em class="xref py py-obj">elec_from</em> to <em class="xref py py-obj">elec_to</em>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.transmission_bulk" title="sisl.io.tbtrans.phtncSileTBtrans.transmission_bulk"><code class="xref py py-obj docutils literal"><span class="pre">transmission_bulk</span></code></a>([elec,&nbsp;kavg])</td>
<td>Bulk transmission for the <em class="xref py py-obj">elec</em> electrode</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.transmission_eig" title="sisl.io.tbtrans.phtncSileTBtrans.transmission_eig"><code class="xref py py-obj docutils literal"><span class="pre">transmission_eig</span></code></a>([elec_from,&nbsp;elec_to,&nbsp;kavg])</td>
<td>Transmission eigenvalues from <em class="xref py py-obj">elec_from</em> to <em class="xref py py-obj">elec_to</em>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.vector_current" title="sisl.io.tbtrans.phtncSileTBtrans.vector_current"><code class="xref py py-obj docutils literal"><span class="pre">vector_current</span></code></a>(elec,&nbsp;E[,&nbsp;kavg,&nbsp;only])</td>
<td>Vector for each atom describing the <em>mean</em> path for the current travelling through the atom</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.vector_current_from_bond" title="sisl.io.tbtrans.phtncSileTBtrans.vector_current_from_bond"><code class="xref py py-obj docutils literal"><span class="pre">vector_current_from_bond</span></code></a>(Jab)</td>
<td>Vector for each atom being the sum of bond-current times the normalized bond between the atoms</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.write" title="sisl.io.tbtrans.phtncSileTBtrans.write"><code class="xref py py-obj docutils literal"><span class="pre">write</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Generic write method which should be overloaded in child-classes</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.write_geometry" title="sisl.io.tbtrans.phtncSileTBtrans.write_geometry"><code class="xref py py-obj docutils literal"><span class="pre">write_geometry</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>This is not meant to be used</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.write_tbtav" title="sisl.io.tbtrans.phtncSileTBtrans.write_tbtav"><code class="xref py py-obj docutils literal"><span class="pre">write_tbtav</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Convert this to a TBT.AV.nc file, i.e.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.ADOS">
<code class="descname">ADOS</code><span class="sig-paren">(</span><em>elec=0</em>, <em>E=None</em>, <em>kavg=True</em>, <em>atom=None</em>, <em>orbital=None</em>, <em>sum=True</em>, <em>norm='none'</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.ADOS" title="Permalink to this definition">¶</a></dt>
<dd><p>Spectral density of states (DOS) (1/eV).</p>
<p>Extract the spectral DOS from electrode <em class="xref py py-obj">elec</em> on a selected subset of atoms/orbitals in the device region</p>
<div class="math">
\[\mathrm{ADOS}_\mathfrak{el}(E) = \frac{1}{2\pi N} \sum_{\nu\in \mathrm{atom}/\mathrm{orbital}} [\mathbf{G}(E)\Gamma_\mathfrak{el}\mathbf{G}^\dagger]_{\nu\nu}(E)\]</div>
<p>The normalization constant (<span class="math">\(N\)</span>) is defined in the routine <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.norm" title="sisl.io.tbtrans.phtncSileTBtrans.norm"><code class="xref py py-obj docutils literal"><span class="pre">norm</span></code></a> and depends on the
arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec: str, int, optional</strong></p>
<blockquote>
<div><p>electrode originating spectral function</p>
</div></blockquote>
<p><strong>E</strong> : float or int, optional</p>
<blockquote>
<div><p>optionally only return the DOS of atoms at a given energy point</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote>
<div><p>whether the returned DOS is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
<p><strong>atom</strong> : array_like of int or bool, optional</p>
<blockquote>
<div><p>only return for a given set of atoms (default to all).
<em>NOT</em> allowed with <em class="xref py py-obj">orbital</em> keyword</p>
</div></blockquote>
<p><strong>orbital</strong> : array_like of int or bool, optional</p>
<blockquote>
<div><p>only return for a given set of orbitals (default to all)
<em>NOT</em> allowed with <em class="xref py py-obj">atom</em> keyword</p>
</div></blockquote>
<p><strong>sum</strong> : bool, optional</p>
<blockquote>
<div><p>whether the returned quantities are summed or returned <em>as is</em>, i.e. resolved per atom/orbital.</p>
</div></blockquote>
<p><strong>norm</strong> : {‘none’, ‘atom’, ‘orbital’, ‘all’}</p>
<blockquote class="last">
<div><p>how the normalization of the summed DOS is performed (see <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.norm" title="sisl.io.tbtrans.phtncSileTBtrans.norm"><code class="xref py py-obj docutils literal"><span class="pre">norm</span></code></a> routine).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.DOS" title="sisl.io.tbtrans.phtncSileTBtrans.DOS"><code class="xref py py-obj docutils literal"><span class="pre">DOS</span></code></a></dt>
<dd>the total density of states (including bound states)</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.BDOS" title="sisl.io.tbtrans.phtncSileTBtrans.BDOS"><code class="xref py py-obj docutils literal"><span class="pre">BDOS</span></code></a></dt>
<dd>the bulk density of states in an electrode</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.Adensity_matrix">
<code class="descname">Adensity_matrix</code><span class="sig-paren">(</span><em>elec</em>, <em>E</em>, <em>kavg=True</em>, <em>isc=None</em>, <em>geometry=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.Adensity_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Spectral function density matrix at energy <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.E" title="sisl.io.tbtrans.phtncSileTBtrans.E"><code class="xref py py-obj docutils literal"><span class="pre">E</span></code></a> (1/eV)</p>
<p>The density matrix can be used to calculate the LDOS in real-space.</p>
<p>The <span class="math">\(\mathrm{LDOS}(E, \mathbf r)\)</span> may be calculated using the <a class="reference internal" href="sisl.physics.DensityMatrix.html#sisl.physics.DensityMatrix.density" title="sisl.physics.DensityMatrix.density"><code class="xref py py-obj docutils literal"><span class="pre">density</span></code></a>
routine. Basically the LDOS in real-space may be calculated as</p>
<div class="math">
\[\rho_{\mathbf A_{\mathfrak{el}}}(E, \mathbf r) = \frac{1}{2\pi}\sum_{\nu\mu}\phi_\nu(\mathbf r)\phi_\mu(\mathbf r) \Re[\mathbf A_{\mathfrak{el}, \nu\mu}(E)]\]</div>
<p>where <span class="math">\(\phi\)</span> are the orbitals. Note that the broadening used in the TBtrans calculations
ensures the broadening of the density, i.e. it should not be necessary to perform energy
averages over the density matrices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec: str or int</strong></p>
<blockquote>
<div><p>the electrode of originating electrons</p>
</div></blockquote>
<p><strong>E</strong> : float or int</p>
<blockquote>
<div><p>the energy or the energy index of density matrix. If an integer
is passed it is the index, otherwise the index corresponding to
<code class="docutils literal"><span class="pre">Eindex(E)</span></code> is used.</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote>
<div><p>whether the returned density matrix is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
<p><strong>isc: array_like, optional</strong></p>
<blockquote>
<div><p>the returned density matrix from unit-cell (<code class="docutils literal"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></code>) to
the given supercell, the default is all density matrix elements for the supercell.
To only get unit cell orbital currents, pass <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>.</p>
</div></blockquote>
<p><strong>geometry: Geometry, optional</strong></p>
<blockquote>
<div><p>geometry that will be associated with the density matrix. By default the
geometry contained in this file will be used. However, then the
atomic species are probably incorrect, nor will the orbitals contain
the basis-set information required to generate the required density
in real-space.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">DensityMatrix: the object containing the Geometry and the density matrix elements</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.density_matrix" title="sisl.io.tbtrans.phtncSileTBtrans.density_matrix"><code class="xref py py-obj docutils literal"><span class="pre">density_matrix</span></code></a></dt>
<dd>Green function density matrix</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.BDOS">
<code class="descname">BDOS</code><span class="sig-paren">(</span><em>elec=0</em>, <em>E=None</em>, <em>kavg=True</em>, <em>sum=True</em>, <em>norm='none'</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.BDOS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bulk density of states (DOS) (1/eV).</p>
<p>Extract the bulk DOS from electrode <em class="xref py py-obj">elec</em> on a selected subset of atoms/orbitals in the device region</p>
<div class="math">
\[\mathrm{BDOS}_\mathfrak{el}(E) = -\frac{1}{\pi} \Im\mathbf{G}(E)\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec: str, int, optional</strong></p>
<blockquote>
<div><p>electrode where the bulk DOS is returned</p>
</div></blockquote>
<p><strong>E</strong> : float or int, optional</p>
<blockquote>
<div><p>optionally only return the DOS of atoms at a given energy point</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote>
<div><p>whether the returned DOS is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
<p><strong>sum</strong> : bool, optional</p>
<blockquote>
<div><p>whether the returned quantities are summed or returned <em>as is</em>, i.e. resolved per atom/orbital.</p>
</div></blockquote>
<p><strong>norm</strong> : {‘none’, ‘atom’, ‘orbital’, ‘all’}</p>
<blockquote class="last">
<div><p>whether the returned quantities are summed or normed by total number of orbitals.
Currently one cannot extract DOS per atom/orbital.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.DOS" title="sisl.io.tbtrans.phtncSileTBtrans.DOS"><code class="xref py py-obj docutils literal"><span class="pre">DOS</span></code></a></dt>
<dd>the total density of states (including bound states)</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.ADOS" title="sisl.io.tbtrans.phtncSileTBtrans.ADOS"><code class="xref py py-obj docutils literal"><span class="pre">ADOS</span></code></a></dt>
<dd>the spectral density of states from an electrode</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.DOS">
<code class="descname">DOS</code><span class="sig-paren">(</span><em>E=None</em>, <em>kavg=True</em>, <em>atom=None</em>, <em>orbital=None</em>, <em>sum=True</em>, <em>norm='none'</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.DOS" title="Permalink to this definition">¶</a></dt>
<dd><p>Green function density of states (DOS) (1/eV).</p>
<p>Extract the DOS on a selected subset of atoms/orbitals in the device region</p>
<div class="math">
\[\mathrm{DOS}(E) = -\frac{1}{\pi N} \sum_{\nu\in \mathrm{atom}/\mathrm{orbital}} \Im \mathbf{G}_{\nu\nu}(E)\]</div>
<p>The normalization constant (<span class="math">\(N\)</span>) is defined in the routine <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.norm" title="sisl.io.tbtrans.phtncSileTBtrans.norm"><code class="xref py py-obj docutils literal"><span class="pre">norm</span></code></a> and depends on the
arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>E</strong> : float or int, optional</p>
<blockquote>
<div><p>optionally only return the DOS of atoms at a given energy point</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote>
<div><p>whether the returned DOS is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
<p><strong>atom</strong> : array_like of int or bool, optional</p>
<blockquote>
<div><p>only return for a given set of atoms (default to all).
<em>NOT</em> allowed with <em class="xref py py-obj">orbital</em> keyword</p>
</div></blockquote>
<p><strong>orbital</strong> : array_like of int or bool, optional</p>
<blockquote>
<div><p>only return for a given set of orbitals (default to all)
<em>NOT</em> allowed with <em class="xref py py-obj">atom</em> keyword</p>
</div></blockquote>
<p><strong>sum</strong> : bool, optional</p>
<blockquote>
<div><p>whether the returned quantities are summed or returned <em>as is</em>, i.e. resolved per atom/orbital.</p>
</div></blockquote>
<p><strong>norm</strong> : {‘none’, ‘atom’, ‘orbital’, ‘all’}</p>
<blockquote class="last">
<div><p>how the normalization of the summed DOS is performed (see <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.norm" title="sisl.io.tbtrans.phtncSileTBtrans.norm"><code class="xref py py-obj docutils literal"><span class="pre">norm</span></code></a> routine)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.ADOS" title="sisl.io.tbtrans.phtncSileTBtrans.ADOS"><code class="xref py py-obj docutils literal"><span class="pre">ADOS</span></code></a></dt>
<dd>the spectral density of states from an electrode</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.BDOS" title="sisl.io.tbtrans.phtncSileTBtrans.BDOS"><code class="xref py py-obj docutils literal"><span class="pre">BDOS</span></code></a></dt>
<dd>the bulk density of states in an electrode</dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.E">
<code class="descname">E</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.E" title="Permalink to this definition">¶</a></dt>
<dd><p>Sampled energy-points in file</p>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.Eindex">
<code class="descname">Eindex</code><span class="sig-paren">(</span><em>E</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.Eindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the closest energy index corresponding to the energy <code class="docutils literal"><span class="pre">E</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>E</strong> : float or int</p>
<blockquote class="last">
<div><p>if <code class="docutils literal"><span class="pre">int</span></code>, return it-self, else return the energy index which is
closests to the energy.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.a2p">
<code class="descname">a2p</code><span class="sig-paren">(</span><em>atom</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.a2p" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pivoting orbital indices (0-based) for the atoms</p>
<p>This is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">o2p</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="bp">True</span><span class="p">))</span> 
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : array_like or int</p>
<blockquote class="last">
<div><p>atomic indices (0-based)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.a_dev">
<code class="descname">a_dev</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.a_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomic indices (0-based) of device atoms</p>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.atom_ACOHP">
<code class="descname">atom_ACOHP</code><span class="sig-paren">(</span><em>elec</em>, <em>E</em>, <em>kavg=True</em>, <em>isc=None</em>, <em>uc=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_ACOHP" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomic COHP curve of the spectral function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec: str or int</strong></p>
<blockquote>
<div><p>the electrode of the spectral function</p>
</div></blockquote>
<p><strong>E: float or int</strong></p>
<blockquote>
<div><p>the energy or the energy index of COHP. If an integer
is passed it is the index, otherwise the index corresponding to
<code class="docutils literal"><span class="pre">Eindex(E)</span></code> is used.</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote>
<div><p>whether the returned COHP is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
<p><strong>isc: array_like, optional</strong></p>
<blockquote>
<div><p>the returned COHP from unit-cell (<code class="docutils literal"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></code>) to
the given supercell, the default is all COHP for the supercell.
To only get unit cell orbital currents, pass <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>.</p>
</div></blockquote>
<p><strong>uc</strong> : bool, optional</p>
<blockquote class="last">
<div><p>whether the returned COHP are only in the unit-cell.
If <code class="docutils literal"><span class="pre">True</span></code> this will return a sparse matrix of <code class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(self.na,</span> <span class="pre">self.na)</span></code>,
else, it will return a sparse matrix of <code class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(self.na,</span> <span class="pre">self.na</span> <span class="pre">*</span> <span class="pre">self.n_s)</span></code>.
One may figure out the connections via <code class="xref py py-obj docutils literal"><span class="pre">sc_index</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_COHP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_COHP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_COHP</span></code></a></dt>
<dd>orbital resolved COHP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COHP_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COHP_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">atom_COHP_from_orbital</span></code></a></dt>
<dd>transfer an orbital COHP to atomic COHP</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COHP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COHP"><code class="xref py py-obj docutils literal"><span class="pre">atom_COHP</span></code></a></dt>
<dd>atomic COHP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_ACOOP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_ACOOP"><code class="xref py py-obj docutils literal"><span class="pre">atom_ACOOP</span></code></a></dt>
<dd>atomic COOP analysis of the spectral function</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.atom_ACOOP">
<code class="descname">atom_ACOOP</code><span class="sig-paren">(</span><em>elec</em>, <em>E</em>, <em>kavg=True</em>, <em>isc=None</em>, <em>uc=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_ACOOP" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomic COOP curve of the spectral function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec: str or int</strong></p>
<blockquote>
<div><p>the electrode of the spectral function</p>
</div></blockquote>
<p><strong>E: float or int</strong></p>
<blockquote>
<div><p>the energy or the energy index of COOP. If an integer
is passed it is the index, otherwise the index corresponding to
<code class="docutils literal"><span class="pre">Eindex(E)</span></code> is used.</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote>
<div><p>whether the returned COOP is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
<p><strong>isc: array_like, optional</strong></p>
<blockquote>
<div><p>the returned COOP from unit-cell (<code class="docutils literal"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></code>) to
the given supercell, the default is all COOP for the supercell.
To only get unit cell orbital currents, pass <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>.</p>
</div></blockquote>
<p><strong>uc</strong> : bool, optional</p>
<blockquote class="last">
<div><p>whether the returned COOP are only in the unit-cell.
If <code class="docutils literal"><span class="pre">True</span></code> this will return a sparse matrix of <code class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(self.na,</span> <span class="pre">self.na)</span></code>,
else, it will return a sparse matrix of <code class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(self.na,</span> <span class="pre">self.na</span> <span class="pre">*</span> <span class="pre">self.n_s)</span></code>.
One may figure out the connections via <code class="xref py py-obj docutils literal"><span class="pre">sc_index</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_COOP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_COOP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_COOP</span></code></a></dt>
<dd>orbital resolved COOP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COOP_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COOP_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">atom_COOP_from_orbital</span></code></a></dt>
<dd>transfer an orbital COOP to atomic COOP</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COOP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COOP"><code class="xref py py-obj docutils literal"><span class="pre">atom_COOP</span></code></a></dt>
<dd>atomic COOP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_ACOHP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_ACOHP"><code class="xref py py-obj docutils literal"><span class="pre">atom_ACOHP</span></code></a></dt>
<dd>atomic COHP analysis of the spectral function</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.atom_COHP">
<code class="descname">atom_COHP</code><span class="sig-paren">(</span><em>E</em>, <em>kavg=True</em>, <em>isc=None</em>, <em>uc=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COHP" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomic COHP curve of the Green function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>E: float or int</strong></p>
<blockquote>
<div><p>the energy or the energy index of COHP. If an integer
is passed it is the index, otherwise the index corresponding to
<code class="docutils literal"><span class="pre">Eindex(E)</span></code> is used.</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote>
<div><p>whether the returned COHP is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
<p><strong>isc: array_like, optional</strong></p>
<blockquote>
<div><p>the returned COHP from unit-cell (<code class="docutils literal"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></code>) to
the given supercell, the default is all COHP for the supercell.
To only get unit cell orbital currents, pass <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>.</p>
</div></blockquote>
<p><strong>uc</strong> : bool, optional</p>
<blockquote class="last">
<div><p>whether the returned COHP are only in the unit-cell.
If <code class="docutils literal"><span class="pre">True</span></code> this will return a sparse matrix of <code class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(self.na,</span> <span class="pre">self.na)</span></code>,
else, it will return a sparse matrix of <code class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(self.na,</span> <span class="pre">self.na</span> <span class="pre">*</span> <span class="pre">self.n_s)</span></code>.
One may figure out the connections via <code class="xref py py-obj docutils literal"><span class="pre">sc_index</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_COHP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_COHP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_COHP</span></code></a></dt>
<dd>orbital resolved COHP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COHP_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COHP_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">atom_COHP_from_orbital</span></code></a></dt>
<dd>transfer an orbital COHP to atomic COHP</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_ACOHP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_ACOHP"><code class="xref py py-obj docutils literal"><span class="pre">atom_ACOHP</span></code></a></dt>
<dd>atomic COHP analysis of the spectral function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COOP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COOP"><code class="xref py py-obj docutils literal"><span class="pre">atom_COOP</span></code></a></dt>
<dd>atomic COOP analysis of the Green function</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.atom_COHP_from_orbital">
<code class="descname">atom_COHP_from_orbital</code><span class="sig-paren">(</span><em>COHP</em>, <em>uc=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COHP_from_orbital" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the atomic COHP curve from the orbital COHP</p>
<p>The atomic COHP are a sum over all orbital COHP:</p>
<div class="math">
\[\mathrm{COHP}_{\alpha\beta} = \sum_{\nu\in\alpha}\sum_{\mu\in\beta} \mathrm{COHP}_{\nu\mu}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>COHP</strong> : scipy.sparse.csr_matrix</p>
<blockquote>
<div><p>the orbital COHP as retrieved from <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_COHP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_COHP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_COHP</span></code></a> or <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOHP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOHP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_ACOHP</span></code></a></p>
</div></blockquote>
<p><strong>uc</strong> : bool, optional</p>
<blockquote class="last">
<div><p>whether the returned COHP are only in the unit-cell.
If <code class="docutils literal"><span class="pre">True</span></code> this will return a sparse matrix of <code class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(self.na,</span> <span class="pre">self.na)</span></code>,
else, it will return a sparse matrix of <code class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(self.na,</span> <span class="pre">self.na</span> <span class="pre">*</span> <span class="pre">self.n_s)</span></code>.
One may figure out the connections via <code class="xref py py-obj docutils literal"><span class="pre">sc_index</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_COHP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_COHP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_COHP</span></code></a></dt>
<dd>orbital resolved COHP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOHP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOHP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_ACOHP</span></code></a></dt>
<dd>orbital resolved COHP analysis of the spectral function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COHP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COHP"><code class="xref py py-obj docutils literal"><span class="pre">atom_COHP</span></code></a></dt>
<dd>atomic COHP analysis of the Green function</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.atom_COOP">
<code class="descname">atom_COOP</code><span class="sig-paren">(</span><em>E</em>, <em>kavg=True</em>, <em>isc=None</em>, <em>uc=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COOP" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomic COOP curve of the Green function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>E: float or int</strong></p>
<blockquote>
<div><p>the energy or the energy index of COOP. If an integer
is passed it is the index, otherwise the index corresponding to
<code class="docutils literal"><span class="pre">Eindex(E)</span></code> is used.</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote>
<div><p>whether the returned COOP is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
<p><strong>isc: array_like, optional</strong></p>
<blockquote>
<div><p>the returned COOP from unit-cell (<code class="docutils literal"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></code>) to
the given supercell, the default is all COOP for the supercell.
To only get unit cell orbital currents, pass <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>.</p>
</div></blockquote>
<p><strong>uc</strong> : bool, optional</p>
<blockquote class="last">
<div><p>whether the returned COOP are only in the unit-cell.
If <code class="docutils literal"><span class="pre">True</span></code> this will return a sparse matrix of <code class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(self.na,</span> <span class="pre">self.na)</span></code>,
else, it will return a sparse matrix of <code class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(self.na,</span> <span class="pre">self.na</span> <span class="pre">*</span> <span class="pre">self.n_s)</span></code>.
One may figure out the connections via <code class="xref py py-obj docutils literal"><span class="pre">sc_index</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_COOP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_COOP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_COOP</span></code></a></dt>
<dd>orbital resolved COOP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COOP_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COOP_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">atom_COOP_from_orbital</span></code></a></dt>
<dd>transfer an orbital COOP to atomic COOP</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_ACOOP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_ACOOP"><code class="xref py py-obj docutils literal"><span class="pre">atom_ACOOP</span></code></a></dt>
<dd>atomic COOP analysis of the spectral function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COHP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COHP"><code class="xref py py-obj docutils literal"><span class="pre">atom_COHP</span></code></a></dt>
<dd>atomic COHP analysis of the Green function</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.atom_COOP_from_orbital">
<code class="descname">atom_COOP_from_orbital</code><span class="sig-paren">(</span><em>COOP</em>, <em>uc=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COOP_from_orbital" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the atomic COOP curve from the orbital COOP</p>
<p>The atomic COOP are a sum over all orbital COOP:</p>
<div class="math">
\[\mathrm{COOP}_{\alpha\beta} = \sum_{\nu\in\alpha}\sum_{\mu\in\beta} \mathrm{COOP}_{\nu\mu}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>COOP</strong> : scipy.sparse.csr_matrix</p>
<blockquote>
<div><p>the orbital COOP as retrieved from <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_COOP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_COOP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_COOP</span></code></a> or <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOOP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOOP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_ACOOP</span></code></a></p>
</div></blockquote>
<p><strong>uc</strong> : bool, optional</p>
<blockquote class="last">
<div><p>whether the returned COOP are only in the unit-cell.
If <code class="docutils literal"><span class="pre">True</span></code> this will return a sparse matrix of <code class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(self.na,</span> <span class="pre">self.na)</span></code>,
else, it will return a sparse matrix of <code class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(self.na,</span> <span class="pre">self.na</span> <span class="pre">*</span> <span class="pre">self.n_s)</span></code>.
One may figure out the connections via <code class="xref py py-obj docutils literal"><span class="pre">sc_index</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_COOP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_COOP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_COOP</span></code></a></dt>
<dd>orbital resolved COOP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOOP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOOP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_ACOOP</span></code></a></dt>
<dd>orbital resolved COOP analysis of the spectral function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COOP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COOP"><code class="xref py py-obj docutils literal"><span class="pre">atom_COOP</span></code></a></dt>
<dd>atomic COOP analysis of the Green function</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.atom_current">
<code class="descname">atom_current</code><span class="sig-paren">(</span><em>elec</em>, <em>E</em>, <em>kavg=True</em>, <em>activity=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_current" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomic current of atoms</p>
<p>Short hand function for calling <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_current" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_current"><code class="xref py py-obj docutils literal"><span class="pre">orbital_current</span></code></a> and <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_current_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.atom_current_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">atom_current_from_orbital</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec: str, int</strong></p>
<blockquote>
<div><p>the electrode of originating electrons</p>
</div></blockquote>
<p><strong>E: float or int</strong></p>
<blockquote>
<div><p>the energy or energy index of the atom current.</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote>
<div><p>whether the returned atomic current is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
<p><strong>activity: bool, optional</strong></p>
<blockquote class="last">
<div><p>whether the activity current is returned, see <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_current_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.atom_current_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">atom_current_from_orbital</span></code></a> for details.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_current" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_current"><code class="xref py py-obj docutils literal"><span class="pre">orbital_current</span></code></a></dt>
<dd>the orbital current between individual orbitals</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.bond_current_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.bond_current_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">bond_current_from_orbital</span></code></a></dt>
<dd>transfer the orbital current to bond current</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.bond_current" title="sisl.io.tbtrans.phtncSileTBtrans.bond_current"><code class="xref py py-obj docutils literal"><span class="pre">bond_current</span></code></a></dt>
<dd>the bond current (orbital current summed over orbitals)</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.vector_current" title="sisl.io.tbtrans.phtncSileTBtrans.vector_current"><code class="xref py py-obj docutils literal"><span class="pre">vector_current</span></code></a></dt>
<dd>an atomic field current for each atom (Cartesian representation of bond-currents)</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.atom_current_from_orbital">
<code class="descname">atom_current_from_orbital</code><span class="sig-paren">(</span><em>Jij</em>, <em>activity=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_current_from_orbital" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomic current of atoms by passing the orbital current</p>
<p>The atomic current is a single number specifying a figure of the <em>magnitude</em>
current flowing through each atom. It is thus <em>not</em> a quantity that can be related to
the physical current flowing in/out of atoms but is merely a number that provides an
idea of <em>how much</em> current this atom is redistributing.</p>
<p>The atomic current may have two meanings based on these two equations</p>
<div class="math">
\[\begin{split}J_\alpha^{|a|} &amp;=\frac{1}{2} \sum_\beta \Big| \sum_{\nu\in \alpha}\sum_{\mu\in \beta} J_{\nu\mu} \Big|
\\
J_\alpha^{|o|} &amp;=\frac{1}{2} \sum_\beta \sum_{\nu\in \alpha}\sum_{\mu\in \beta} \big| J_{\nu\mu} \big|\end{split}\]</div>
<p>If the <em>activity</em> current is requested (<code class="docutils literal"><span class="pre">activity=True</span></code>)
<span class="math">\(J_\alpha^{\mathcal A} = \sqrt{ J_\alpha^{|a|} J_\alpha^{|o|} }\)</span> is returned.</p>
<p>If <code class="docutils literal"><span class="pre">activity=False</span></code> <span class="math">\(J_\alpha^{|a|}\)</span> is returned.</p>
<p>For geometries with all atoms only having 1-orbital, they are equivalent.</p>
<p>Generally the activity current is a more rigorous figure of merit for the current
flowing through an atom. More so than than the summed absolute atomic current due to
the following reasoning. The activity current is a geometric mean of the absolute bond current
and the absolute orbital current. This means that if there is an atom with a large orbital current
it will have a larger activity current.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Jij: scipy.sparse.csr_matrix</strong></p>
<blockquote>
<div><p>the orbital currents as retrieved from <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_current" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_current"><code class="xref py py-obj docutils literal"><span class="pre">orbital_current</span></code></a></p>
</div></blockquote>
<p><strong>activity: bool, optional</strong></p>
<blockquote class="last">
<div><p><code class="docutils literal"><span class="pre">True</span></code> to return the activity current, see explanation above</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Jij</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">orbital_current</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.03</span><span class="p">)</span> <span class="c1"># orbital current @ E = -1 eV originating from electrode ``0`` </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Ja</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">atom_current_from_orbital</span><span class="p">(</span><span class="n">Jij</span><span class="p">)</span> 
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.bond_current">
<code class="descname">bond_current</code><span class="sig-paren">(</span><em>elec</em>, <em>E</em>, <em>kavg=True</em>, <em>isc=None</em>, <em>only='+'</em>, <em>uc=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.bond_current" title="Permalink to this definition">¶</a></dt>
<dd><p>Bond-current between atoms (sum of orbital currents)</p>
<p>Short hand function for calling <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_current" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_current"><code class="xref py py-obj docutils literal"><span class="pre">orbital_current</span></code></a> and <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.bond_current_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.bond_current_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">bond_current_from_orbital</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec</strong> : str, int</p>
<blockquote>
<div><p>the electrode of originating electrons</p>
</div></blockquote>
<p><strong>E</strong> : float or int</p>
<blockquote>
<div><p>A <em class="xref py py-obj">float</em> for energy in eV, <em class="xref py py-obj">int</em> for explicit energy index
Unlike <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_current" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_current"><code class="xref py py-obj docutils literal"><span class="pre">orbital_current</span></code></a> this may not be <em class="xref py py-obj">None</em> as the down-scaling of the
orbital currents may not be equivalent for all energy points.</p>
</div></blockquote>
<p><strong>kavg</strong> : bool, int or array_like, optional</p>
<blockquote>
<div><p>whether the returned bond current is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
<p><strong>isc</strong> : array_like, optional</p>
<blockquote>
<div><p>the returned bond currents from the unit-cell (<code class="docutils literal"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></code>) (default) to
the given supercell. If <code class="docutils literal"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></code> is passed all
bond currents are returned.</p>
</div></blockquote>
<p><strong>only</strong> : {‘+’, ‘-‘, ‘all’}</p>
<blockquote>
<div><p>If “+” is supplied only the positive orbital currents are used,
for “-“, only the negative orbital currents are used,
else return the sum of both. Please see discussion in <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_current" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_current"><code class="xref py py-obj docutils literal"><span class="pre">orbital_current</span></code></a>.</p>
</div></blockquote>
<p><strong>uc</strong> : bool, optional</p>
<blockquote class="last">
<div><p>whether the returned bond-currents are only in the unit-cell.
If <em class="xref py py-obj">True</em> this will return a sparse matrix of <code class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(self.na,</span> <span class="pre">self.na)</span></code>,
else, it will return a sparse matrix of <code class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(self.na,</span> <span class="pre">self.na</span> <span class="pre">*</span> <span class="pre">self.n_s)</span></code>.
One may figure out the connections via <code class="xref py py-obj docutils literal"><span class="pre">sc_index</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_current" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_current"><code class="xref py py-obj docutils literal"><span class="pre">orbital_current</span></code></a></dt>
<dd>the orbital current between individual orbitals</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.bond_current_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.bond_current_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">bond_current_from_orbital</span></code></a></dt>
<dd>transfer the orbital current to bond current</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_current" title="sisl.io.tbtrans.phtncSileTBtrans.atom_current"><code class="xref py py-obj docutils literal"><span class="pre">atom_current</span></code></a></dt>
<dd>the atomic current for each atom (scalar representation of bond-currents)</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.vector_current" title="sisl.io.tbtrans.phtncSileTBtrans.vector_current"><code class="xref py py-obj docutils literal"><span class="pre">vector_current</span></code></a></dt>
<dd>an atomic field current for each atom (Cartesian representation of bond-currents)</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Jij</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">orbital_current</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">only</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">)</span> <span class="c1"># orbital current @ E = -1 eV originating from electrode ``0`` </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Jab1</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">bond_current_from_orbital</span><span class="p">(</span><span class="n">Jij</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">Jab2</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">bond_current</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">Jab1</span> <span class="o">==</span> <span class="n">Jab2</span> 
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.bond_current_from_orbital">
<code class="descname">bond_current_from_orbital</code><span class="sig-paren">(</span><em>Jij</em>, <em>only='+'</em>, <em>uc=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.bond_current_from_orbital" title="Permalink to this definition">¶</a></dt>
<dd><p>Bond-current between atoms (sum of orbital currents) from an external orbital current</p>
<p>Conversion routine from orbital currents into bond currents.</p>
<p>The bond currents are a sum over all orbital currents:</p>
<div class="math">
\[J_{\alpha\beta} = \sum_{\nu\in\alpha}\sum_{\mu\in\beta} J_{\nu\mu}\]</div>
<p>where if</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">only='+'</span></code>:
only <span class="math">\(J_{\nu\mu} &gt; 0\)</span> are summed onto the corresponding atom,</li>
<li><code class="docutils literal"><span class="pre">only='-'</span></code>:
only <span class="math">\(J_{\nu\mu} &lt; 0\)</span> are summed onto the corresponding atom,</li>
<li><code class="docutils literal"><span class="pre">only='all'</span></code>:
all <span class="math">\(J_{\nu\mu}\)</span> are summed onto the corresponding atom.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Jij</strong> : scipy.sparse.csr_matrix</p>
<blockquote>
<div><p>the orbital currents as retrieved from <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_current" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_current"><code class="xref py py-obj docutils literal"><span class="pre">orbital_current</span></code></a></p>
</div></blockquote>
<p><strong>only</strong> : {‘+’, ‘-‘, ‘all’}</p>
<blockquote>
<div><p>If “+” is supplied only the positive orbital currents are used,
for “-“, only the negative orbital currents are used,
else return both.</p>
</div></blockquote>
<p><strong>uc</strong> : bool, optional</p>
<blockquote class="last">
<div><p>whether the returned bond-currents are only in the unit-cell.
If <code class="docutils literal"><span class="pre">True</span></code> this will return a sparse matrix of <code class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(self.na,</span> <span class="pre">self.na)</span></code>,
else, it will return a sparse matrix of <code class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">(self.na,</span> <span class="pre">self.na</span> <span class="pre">*</span> <span class="pre">self.n_s)</span></code>.
One may figure out the connections via <code class="xref py py-obj docutils literal"><span class="pre">sc_index</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_current" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_current"><code class="xref py py-obj docutils literal"><span class="pre">orbital_current</span></code></a></dt>
<dd>the orbital current between individual orbitals</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.bond_current" title="sisl.io.tbtrans.phtncSileTBtrans.bond_current"><code class="xref py py-obj docutils literal"><span class="pre">bond_current</span></code></a></dt>
<dd>the bond current (orbital current summed over orbitals)</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_current" title="sisl.io.tbtrans.phtncSileTBtrans.atom_current"><code class="xref py py-obj docutils literal"><span class="pre">atom_current</span></code></a></dt>
<dd>the atomic current for each atom (scalar representation of bond-currents)</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.vector_current" title="sisl.io.tbtrans.phtncSileTBtrans.vector_current"><code class="xref py py-obj docutils literal"><span class="pre">vector_current</span></code></a></dt>
<dd>an atomic field current for each atom (Cartesian representation of bond-currents)</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Jij</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">orbital_current</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="c1"># orbital current @ E = -1 eV originating from electrode ``0`` </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Jab</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">bond_current_from_orbital</span><span class="p">(</span><span class="n">Jij</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">Jab</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># bond current between atom 3 and 4 </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.btd">
<code class="descname">btd</code><span class="sig-paren">(</span><em>elec=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.btd" title="Permalink to this definition">¶</a></dt>
<dd><p>Block-sizes for the BTD method</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec</strong> : str or int, optional</p>
<blockquote class="last">
<div><p>if None the number of blocks in the device region BTD matrix. Else
the number of BTD blocks in the electrode down-folding.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.cell">
<code class="descname">cell</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Unit cell in file</p>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.chemical_potential">
<code class="descname">chemical_potential</code><span class="sig-paren">(</span><em>elec</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.chemical_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chemical potential associated with the electrode <em class="xref py py-obj">elec</em></p>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.close" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.current">
<code class="descname">current</code><span class="sig-paren">(</span><em>elec_from=0</em>, <em>elec_to=1</em>, <em>kavg=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.current" title="Permalink to this definition">¶</a></dt>
<dd><p>Current from <em class="xref py py-obj">from</em> to <em class="xref py py-obj">to</em> using the k-weights and energy spacings in the file.</p>
<p>Calculates the current as:</p>
<div class="math">
\[I(\mu_t - \mu_f) = \frac{e}{h}\int\!\mathrm{d}E\, T(E) [n_F(\mu_t, k_B T_t) - n_F(\mu_f, k_B T_f)]\]</div>
<p>The chemical potential and the temperature are taken from this object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec_from: str, int, optional</strong></p>
<blockquote>
<div><p>the originating electrode</p>
</div></blockquote>
<p><strong>elec_to: str, int, optional</strong></p>
<blockquote>
<div><p>the absorbing electrode (different from <em class="xref py py-obj">elec_from</em>)</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote class="last">
<div><p>whether the returned current is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.current_parameter" title="sisl.io.tbtrans.phtncSileTBtrans.current_parameter"><code class="xref py py-obj docutils literal"><span class="pre">current_parameter</span></code></a></dt>
<dd>to explicitly set the electronic temperature and chemical potentials</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.chemical_potential" title="sisl.io.tbtrans.phtncSileTBtrans.chemical_potential"><code class="xref py py-obj docutils literal"><span class="pre">chemical_potential</span></code></a></dt>
<dd>routine that defines the chemical potential of the queried electrodes</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.kT" title="sisl.io.tbtrans.phtncSileTBtrans.kT"><code class="xref py py-obj docutils literal"><span class="pre">kT</span></code></a></dt>
<dd>routine that defines the electronic temperature of the queried electrodes</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.current_parameter">
<code class="descname">current_parameter</code><span class="sig-paren">(</span><em>elec_from</em>, <em>mu_from</em>, <em>kt_from</em>, <em>elec_to</em>, <em>mu_to</em>, <em>kt_to</em>, <em>kavg=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.current_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Current from <em class="xref py py-obj">from</em> to <em class="xref py py-obj">to</em> using the k-weights and energy spacings in the file.</p>
<p>Calculates the current as:</p>
<div class="math">
\[I(\mu_t - \mu_f) = \frac{e}{h}\int\!\mathrm{d}E\, T(E) [n_F(\mu_t, k_B T_t) - n_F(\mu_f, k_B T_f)]\]</div>
<p>The chemical potential and the temperature are passed as arguments to
this routine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec_from: str, int</strong></p>
<blockquote>
<div><p>the originating electrode</p>
</div></blockquote>
<p><strong>mu_from: float</strong></p>
<blockquote>
<div><p>the chemical potential of the electrode (in eV)</p>
</div></blockquote>
<p><strong>kt_from: float</strong></p>
<blockquote>
<div><p>the electronic temperature of the electrode (in eV)</p>
</div></blockquote>
<p><strong>elec_to: str, int</strong></p>
<blockquote>
<div><p>the absorbing electrode (different from <em class="xref py py-obj">elec_from</em>)</p>
</div></blockquote>
<p><strong>mu_to: float</strong></p>
<blockquote>
<div><p>the chemical potential of the electrode (in eV)</p>
</div></blockquote>
<p><strong>kt_to: float</strong></p>
<blockquote>
<div><p>the electronic temperature of the electrode (in eV)</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote class="last">
<div><p>whether the returned current is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.current" title="sisl.io.tbtrans.phtncSileTBtrans.current"><code class="xref py py-obj docutils literal"><span class="pre">current</span></code></a></dt>
<dd>which calculates the current with the chemical potentials and temperatures set in the TBtrans calculation</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.density_matrix">
<code class="descname">density_matrix</code><span class="sig-paren">(</span><em>E</em>, <em>kavg=True</em>, <em>isc=None</em>, <em>geometry=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.density_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Density matrix from the Green function at energy <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.E" title="sisl.io.tbtrans.phtncSileTBtrans.E"><code class="xref py py-obj docutils literal"><span class="pre">E</span></code></a> (1/eV)</p>
<p>The density matrix can be used to calculate the LDOS in real-space.</p>
<p>The <span class="math">\(\mathrm{LDOS}(E, \mathbf r)\)</span> may be calculated using the <a class="reference internal" href="sisl.physics.DensityMatrix.html#sisl.physics.DensityMatrix.density" title="sisl.physics.DensityMatrix.density"><code class="xref py py-obj docutils literal"><span class="pre">density</span></code></a>
routine. Basically the LDOS in real-space may be calculated as</p>
<div class="math">
\[\rho_{\mathbf G}(E, \mathbf r) = -\frac{1}{\pi}\sum_{\nu\mu}\phi_\nu(\mathbf r)\phi_\mu(\mathbf r) \Im[\mathbf G_{\nu\mu}(E)]\]</div>
<p>where <span class="math">\(\phi\)</span> are the orbitals. Note that the broadening used in the TBtrans calculations
ensures the broadening of the density, i.e. it should not be necessary to perform energy
averages over the density matrices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>E</strong> : float or int</p>
<blockquote>
<div><p>the energy or the energy index of density matrix. If an integer
is passed it is the index, otherwise the index corresponding to
<code class="docutils literal"><span class="pre">Eindex(E)</span></code> is used.</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote>
<div><p>whether the returned density matrix is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
<p><strong>isc: array_like, optional</strong></p>
<blockquote>
<div><p>the returned density matrix from unit-cell (<code class="docutils literal"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></code>) to
the given supercell, the default is all density matrix elements for the supercell.
To only get unit cell orbital currents, pass <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>.</p>
</div></blockquote>
<p><strong>geometry: Geometry, optional</strong></p>
<blockquote>
<div><p>geometry that will be associated with the density matrix. By default the
geometry contained in this file will be used. However, then the
atomic species are probably incorrect, nor will the orbitals contain
the basis-set information required to generate the required density
in real-space.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">DensityMatrix: the object containing the Geometry and the density matrix elements</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.Adensity_matrix" title="sisl.io.tbtrans.phtncSileTBtrans.Adensity_matrix"><code class="xref py py-obj docutils literal"><span class="pre">Adensity_matrix</span></code></a></dt>
<dd>spectral function density matrix</dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.elecs">
<code class="descname">elecs</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.elecs" title="Permalink to this definition">¶</a></dt>
<dd><p>List of electrodes</p>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.electronic_temperature">
<code class="descname">electronic_temperature</code><span class="sig-paren">(</span><em>elec</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.electronic_temperature" title="Permalink to this definition">¶</a></dt>
<dd><p>Return temperature of the electrode electronic distribution in Kelvin</p>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.eta">
<code class="descname">eta</code><span class="sig-paren">(</span><em>elec=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.eta" title="Permalink to this definition">¶</a></dt>
<dd><p>The imaginary part used when calculating the self-energies in eV (or for the device</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec</strong> : str, int, optional</p>
<blockquote class="last">
<div><p>electrode to extract the eta value from. If not specified (or None) the device
region eta will be returned.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.exist">
<code class="descname">exist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.exist" title="Permalink to this definition">¶</a></dt>
<dd><p>Query whether the file exists</p>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.fano">
<code class="descname">fano</code><span class="sig-paren">(</span><em>elec_from=0</em>, <em>elec_to=1</em>, <em>kavg=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.fano" title="Permalink to this definition">¶</a></dt>
<dd><p>The Fano-factor for the calculation (requires calculated transmission eigenvalues)</p>
<p>Calculate the Fano factor defined as:</p>
<div class="math">
\[F(E) = \frac{\sum_n T_n(1 - T_n)}{\sum_n T_n}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec_from: str, int, optional</strong></p>
<blockquote>
<div><p>the originating electrode</p>
</div></blockquote>
<p><strong>elec_to: str, int, optional</strong></p>
<blockquote>
<div><p>the absorbing electrode (different from <em class="xref py py-obj">elec_from</em>)</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote class="last">
<div><p>whether the returned Fano factor is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.shot_noise" title="sisl.io.tbtrans.phtncSileTBtrans.shot_noise"><code class="xref py py-obj docutils literal"><span class="pre">shot_noise</span></code></a></dt>
<dd>routine to calculate the shot-noise</dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.file">
<code class="descname">file</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.file" title="Permalink to this definition">¶</a></dt>
<dd><p>Filename of the current <em class="xref py py-obj">Sile</em></p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.geom">
<code class="descname">geom</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.geom" title="Permalink to this definition">¶</a></dt>
<dd><p>The associated geometry from this file</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.geometry">
<code class="descname">geometry</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>The associated geometry from this file</p>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.info">
<code class="descname">info</code><span class="sig-paren">(</span><em>elec=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Information about the calculated quantities available for extracting in this file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec</strong> : str or int</p>
<blockquote class="last">
<div><p>the electrode to request information from</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.iter">
<code class="descname">iter</code><span class="sig-paren">(</span><em>group=True</em>, <em>dimension=True</em>, <em>variable=True</em>, <em>levels=-1</em>, <em>root=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator on all groups, variables and dimensions.</p>
<p>This iterator iterates through all groups, variables and dimensions in the <code class="docutils literal"><span class="pre">Dataset</span></code></p>
<p>The generator sequence will _always_ be:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Group</li>
<li>Dimensions in group</li>
<li>Variables in group</li>
</ol>
</div></blockquote>
<p>As the dimensions are generated before the variables it is possible to copy
groups, dimensions, and then variables such that one always ensures correct
dependencies in the generation of a new <code class="docutils literal"><span class="pre">SileCDF</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>group</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (<em class="xref py py-obj">True</em>)</p>
<blockquote>
<div><p>whether the iterator yields <em class="xref py py-obj">Group</em> instances</p>
</div></blockquote>
<p><strong>dimension</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (<em class="xref py py-obj">True</em>)</p>
<blockquote>
<div><p>whether the iterator yields <em class="xref py py-obj">Dimension</em> instances</p>
</div></blockquote>
<p><strong>variable</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (<em class="xref py py-obj">True</em>)</p>
<blockquote>
<div><p>whether the iterator yields <em class="xref py py-obj">Variable</em> instances</p>
</div></blockquote>
<p><strong>levels</strong> : <code class="docutils literal"><span class="pre">int</span></code> (<em class="xref py py-obj">-1</em>)</p>
<blockquote>
<div><p>number of levels to traverse, with respect to <code class="docutils literal"><span class="pre">root</span></code> variable, i.e. number of
sub-groups this iterator will return.</p>
</div></blockquote>
<p><strong>root</strong> : <code class="docutils literal"><span class="pre">str</span></code> (<em class="xref py py-obj">None</em>)</p>
<blockquote class="last">
<div><p>the base root to start iterating from.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Script for looping and checking each instance.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">gv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="p">():</span> 
<span class="gp">... </span>    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isGroup</span><span class="p">(</span><span class="n">gv</span><span class="p">):</span> 
<span class="gp">... </span>        <span class="c1"># is group </span>
<span class="gp">... </span>    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">isDimension</span><span class="p">(</span><span class="n">gv</span><span class="p">):</span> 
<span class="gp">... </span>        <span class="c1"># is dimension </span>
<span class="gp">... </span>    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">isVariable</span><span class="p">(</span><span class="n">gv</span><span class="p">):</span> 
<span class="gp">... </span>        <span class="c1"># is variable </span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.k">
<code class="descname">k</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.k" title="Permalink to this definition">¶</a></dt>
<dd><p>Sampled k-points in file</p>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.kT">
<code class="descname">kT</code><span class="sig-paren">(</span><em>elec</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.kT" title="Permalink to this definition">¶</a></dt>
<dd><p>Return temperature of the electrode electronic distribution in eV</p>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.kindex">
<code class="descname">kindex</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.kindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the k-point that is closests to the queried k-point (in reduced coordinates)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>k</strong> : array_like of float</p>
<blockquote class="last">
<div><p>the queried k-point in reduced coordinates <span class="math">\(]-0.5;0.5]\)</span>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.kpt">
<code class="descname">kpt</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.kpt" title="Permalink to this definition">¶</a></dt>
<dd><p>Sampled k-points in file</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.lasto">
<code class="descname">lasto</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.lasto" title="Permalink to this definition">¶</a></dt>
<dd><p>Last orbital of corresponding atom</p>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.mu">
<code class="descname">mu</code><span class="sig-paren">(</span><em>elec</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.mu" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chemical potential associated with the electrode <em class="xref py py-obj">elec</em></p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.nE">
<code class="descname">nE</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.nE" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of energy-points in file</p>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.n_btd">
<code class="descname">n_btd</code><span class="sig-paren">(</span><em>elec=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.n_btd" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of blocks in the BTD partioning</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec</strong> : str or int, optional</p>
<blockquote class="last">
<div><p>if None the number of blocks in the device region BTD matrix. Else
the number of BTD blocks in the electrode down-folding.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.na">
<code class="descname">na</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.na" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of atoms in the cell</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.na_d">
<code class="descname">na_d</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.na_d" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of atoms in the device region</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.na_dev">
<code class="descname">na_dev</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.na_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of atoms in the device region</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.na_u">
<code class="descname">na_u</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.na_u" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of atoms in the cell</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.ne">
<code class="descname">ne</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.ne" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of energy-points in file</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.nk">
<code class="descname">nk</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.nk" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of k-points in file</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.nkpt">
<code class="descname">nkpt</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.nkpt" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of k-points in file</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.no">
<code class="descname">no</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.no" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of orbitals in the cell</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.no_d">
<code class="descname">no_d</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.no_d" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of orbitals in the device region</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.no_u">
<code class="descname">no_u</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.no_u" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of orbitals in the cell</p>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.norm">
<code class="descname">norm</code><span class="sig-paren">(</span><em>atom=None</em>, <em>orbital=None</em>, <em>norm='none'</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalization factor depending on the input</p>
<p>The normalization can be performed in one of the below methods.
In the following <span class="math">\(N\)</span> refers to the normalization constant
that is to be used (i.e. the divisor):</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">'none'</span></code></dt>
<dd><span class="math">\(N=1\)</span></dd>
<dt><code class="docutils literal"><span class="pre">'all'</span></code></dt>
<dd><span class="math">\(N\)</span> equals the number of orbitals in the total device region.</dd>
<dt><code class="docutils literal"><span class="pre">'atom'</span></code></dt>
<dd><span class="math">\(N\)</span> equals the total number of orbitals in the selected
atoms. If <em class="xref py py-obj">orbital</em> is an argument a conversion of <em class="xref py py-obj">orbital</em> to the equivalent
unique atoms is performed, and subsequently the total number of orbitals on the
atoms is used. This makes it possible to compare the fraction of orbital DOS easier.</dd>
<dt><code class="docutils literal"><span class="pre">'orbital'</span></code></dt>
<dd><span class="math">\(N\)</span> is the sum of selected orbitals, if <em class="xref py py-obj">atom</em> is specified, this
is equivalent to the ‘atom’ option.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : array_like of int or bool, optional</p>
<blockquote>
<div><p>only return for a given set of atoms (default to all).
<em>NOT</em> allowed with <em class="xref py py-obj">orbital</em> keyword</p>
</div></blockquote>
<p><strong>orbital</strong> : array_like of int or bool, optional</p>
<blockquote>
<div><p>only return for a given set of orbitals (default to all)
<em>NOT</em> allowed with <em class="xref py py-obj">atom</em> keyword</p>
</div></blockquote>
<p><strong>norm</strong> : {‘none’, ‘atom’, ‘orbital’, ‘all’}</p>
<blockquote class="last">
<div><p>how the normalization of the summed DOS is performed (see <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.norm" title="sisl.io.tbtrans.phtncSileTBtrans.norm"><code class="xref py py-obj docutils literal"><span class="pre">norm</span></code></a> routine)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.o2p">
<code class="descname">o2p</code><span class="sig-paren">(</span><em>orbital</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.o2p" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pivoting indices (0-based) for the orbitals</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>orbital</strong> : array_like or int</p>
<blockquote class="last">
<div><p>orbital indices (0-based)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.o_dev">
<code class="descname">o_dev</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.o_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>Orbital indices (0-based) of device orbitals</p>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOHP">
<code class="descname">orbital_ACOHP</code><span class="sig-paren">(</span><em>elec</em>, <em>E</em>, <em>kavg=True</em>, <em>isc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOHP" title="Permalink to this definition">¶</a></dt>
<dd><p>Orbital resolved COHP analysis of the spectral function</p>
<p>This will return a sparse matrix, see <code class="docutils literal"><span class="pre">scipy.sparse.csr_matrix</span></code> for details.
Each matrix element of the sparse matrix corresponds to the COHP of the
underlying geometry.</p>
<p>The COHP analysis can be written as:</p>
<div class="math">
\[\mathrm{COHP}^{\mathbf A}_{\nu\mu} = \frac{1}{2\pi} \Re\big[\mathbf A_{\nu\mu}
    \mathbf H_{\nu\mu} \big]\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec: str or int</strong></p>
<blockquote>
<div><p>the electrode of the spectral function</p>
</div></blockquote>
<p><strong>E: float or int</strong></p>
<blockquote>
<div><p>the energy or the energy index of COHP. If an integer
is passed it is the index, otherwise the index corresponding to
<code class="docutils literal"><span class="pre">Eindex(E)</span></code> is used.</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote>
<div><p>whether the returned COHP is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
<p><strong>isc: array_like, optional</strong></p>
<blockquote class="last">
<div><p>the returned COHP from unit-cell (<code class="docutils literal"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></code>) to
the given supercell, the default is all COHP for the supercell.
To only get unit cell orbital currents, pass <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_COHP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_COHP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_COHP</span></code></a></dt>
<dd>orbital resolved COHP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COHP_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COHP_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">atom_COHP_from_orbital</span></code></a></dt>
<dd>atomic COHP analysis from an orbital COHP</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COHP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COHP"><code class="xref py py-obj docutils literal"><span class="pre">atom_COHP</span></code></a></dt>
<dd>atomic COHP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_ACOHP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_ACOHP"><code class="xref py py-obj docutils literal"><span class="pre">atom_ACOHP</span></code></a></dt>
<dd>atomic COHP analysis of the spectral function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_COOP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_COOP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_COOP</span></code></a></dt>
<dd>orbital resolved COOP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COOP_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COOP_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">atom_COOP_from_orbital</span></code></a></dt>
<dd>transfer an orbital COOP to atomic COOP</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COOP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COOP"><code class="xref py py-obj docutils literal"><span class="pre">atom_COOP</span></code></a></dt>
<dd>atomic COOP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOOP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOOP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_ACOOP</span></code></a></dt>
<dd>orbital resolved COOP analysis of the spectral function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_ACOOP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_ACOOP"><code class="xref py py-obj docutils literal"><span class="pre">atom_ACOOP</span></code></a></dt>
<dd>atomic COOP analysis of the spectral function</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOOP">
<code class="descname">orbital_ACOOP</code><span class="sig-paren">(</span><em>elec</em>, <em>E</em>, <em>kavg=True</em>, <em>isc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOOP" title="Permalink to this definition">¶</a></dt>
<dd><p>Orbital COOP analysis of the spectral function</p>
<p>This will return a sparse matrix, see <code class="docutils literal"><span class="pre">scipy.sparse.csr_matrix</span></code> for details.
Each matrix element of the sparse matrix corresponds to the COOP of the
underlying geometry.</p>
<p>The COOP analysis can be written as:</p>
<div class="math">
\[\mathrm{COOP}^{\mathbf A}_{\nu\mu} = \frac{1}{2\pi} \Re\big[\mathbf A_{\nu\mu} \mathbf S_{\mu\nu} \big]\]</div>
<p>The sum of the COOP DOS is equal to the DOS:</p>
<div class="math">
\[\mathrm{ADOS}_{\nu} = \sum_\mu \mathrm{COOP}^{\mathbf A}_{\nu\mu}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec: str or int</strong></p>
<blockquote>
<div><p>the electrode of the spectral function</p>
</div></blockquote>
<p><strong>E: float or int</strong></p>
<blockquote>
<div><p>the energy or the energy index of COOP. If an integer
is passed it is the index, otherwise the index corresponding to
<code class="docutils literal"><span class="pre">Eindex(E)</span></code> is used.</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote>
<div><p>whether the returned COOP is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
<p><strong>isc: array_like, optional</strong></p>
<blockquote class="last">
<div><p>the returned COOP from unit-cell (<code class="docutils literal"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></code>) to
the given supercell, the default is all COOP for the supercell.
To only get unit cell orbital currents, pass <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_COOP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_COOP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_COOP</span></code></a></dt>
<dd>orbital resolved COOP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COOP_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COOP_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">atom_COOP_from_orbital</span></code></a></dt>
<dd>transfer an orbital COOP to atomic COOP</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COOP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COOP"><code class="xref py py-obj docutils literal"><span class="pre">atom_COOP</span></code></a></dt>
<dd>atomic COOP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_ACOOP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_ACOOP"><code class="xref py py-obj docutils literal"><span class="pre">atom_ACOOP</span></code></a></dt>
<dd>atomic COOP analysis of the spectral function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_COHP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_COHP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_COHP</span></code></a></dt>
<dd>orbital resolved COHP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COHP_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COHP_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">atom_COHP_from_orbital</span></code></a></dt>
<dd>atomic COHP analysis from an orbital COHP</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COHP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COHP"><code class="xref py py-obj docutils literal"><span class="pre">atom_COHP</span></code></a></dt>
<dd>atomic COHP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOHP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOHP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_ACOHP</span></code></a></dt>
<dd>orbital resolved COHP analysis of the spectral function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_ACOHP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_ACOHP"><code class="xref py py-obj docutils literal"><span class="pre">atom_ACOHP</span></code></a></dt>
<dd>atomic COHP analysis of the spectral function</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">COOP</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">orbital_ACOOP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="c1"># COOP @ E = -1 eV from ``0`` spectral function </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">COOP</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span> <span class="c1"># COOP value between the 11th and 12th orbital </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">COOP</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="n">tbt</span><span class="o">.</span><span class="n">o_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">tbt</span><span class="o">.</span><span class="n">ADOS</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">sum</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="n">tbt</span><span class="o">.</span><span class="n">Eindex</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)]</span> 
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.orbital_COHP">
<code class="descname">orbital_COHP</code><span class="sig-paren">(</span><em>E</em>, <em>kavg=True</em>, <em>isc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_COHP" title="Permalink to this definition">¶</a></dt>
<dd><p>Orbital resolved COHP analysis of the Green function</p>
<p>This will return a sparse matrix, see <code class="docutils literal"><span class="pre">scipy.sparse.csr_matrix</span></code> for details.
Each matrix element of the sparse matrix corresponds to the COHP of the
underlying geometry.</p>
<p>The COHP analysis can be written as:</p>
<div class="math">
\[\mathrm{COHP}^{\mathbf G}_{\nu\mu} = \frac{-1}{2\pi}
  \Im\big[(\mathbf G - \mathbf G^\dagger)_{\nu\mu} \mathbf H_{\mu\nu} \big]\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>E: float or int</strong></p>
<blockquote>
<div><p>the energy or the energy index of COHP. If an integer
is passed it is the index, otherwise the index corresponding to
<code class="docutils literal"><span class="pre">Eindex(E)</span></code> is used.</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote>
<div><p>whether the returned COHP is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
<p><strong>isc: array_like, optional</strong></p>
<blockquote class="last">
<div><p>the returned COHP from unit-cell (<code class="docutils literal"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></code>) to
the given supercell, the default is all COHP for the supercell.
To only get unit cell orbital currents, pass <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COHP_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COHP_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">atom_COHP_from_orbital</span></code></a></dt>
<dd>atomic COHP analysis from an orbital COHP</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COHP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COHP"><code class="xref py py-obj docutils literal"><span class="pre">atom_COHP</span></code></a></dt>
<dd>atomic COHP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOHP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOHP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_ACOHP</span></code></a></dt>
<dd>orbital resolved COHP analysis of the spectral function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_ACOHP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_ACOHP"><code class="xref py py-obj docutils literal"><span class="pre">atom_ACOHP</span></code></a></dt>
<dd>atomic COHP analysis of the spectral function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_COOP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_COOP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_COOP</span></code></a></dt>
<dd>orbital resolved COOP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COOP_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COOP_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">atom_COOP_from_orbital</span></code></a></dt>
<dd>transfer an orbital COOP to atomic COOP</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COOP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COOP"><code class="xref py py-obj docutils literal"><span class="pre">atom_COOP</span></code></a></dt>
<dd>atomic COOP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOOP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOOP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_ACOOP</span></code></a></dt>
<dd>orbital resolved COOP analysis of the spectral function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_ACOOP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_ACOOP"><code class="xref py py-obj docutils literal"><span class="pre">atom_ACOOP</span></code></a></dt>
<dd>atomic COOP analysis of the spectral function</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">COHP</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">orbital_COHP</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="c1"># COHP @ E = -1 eV  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">COHP</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span> <span class="c1"># COHP value between the 11th and 12th orbital </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.orbital_COOP">
<code class="descname">orbital_COOP</code><span class="sig-paren">(</span><em>E</em>, <em>kavg=True</em>, <em>isc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_COOP" title="Permalink to this definition">¶</a></dt>
<dd><p>Orbital COOP analysis of the Green function</p>
<p>This will return a sparse matrix, see <code class="docutils literal"><span class="pre">scipy.sparse.csr_matrix</span></code> for details.
Each matrix element of the sparse matrix corresponds to the COOP of the
underlying geometry.</p>
<p>The COOP analysis can be written as:</p>
<div class="math">
\[\mathrm{COOP}^{\mathbf G}_{\nu\mu} = \frac{-1}{2\pi}
  \Im\big[(\mathbf G - \mathbf G^\dagger)_{\nu\mu} \mathbf S_{\mu\nu} \big]\]</div>
<p>The sum of the COOP DOS is equal to the DOS:</p>
<div class="math">
\[\mathrm{DOS}_{\nu} = \sum_\mu \mathrm{COOP}^{\mathbf G}_{\nu\mu}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>E: float or int</strong></p>
<blockquote>
<div><p>the energy or the energy index of COOP. If an integer
is passed it is the index, otherwise the index corresponding to
<code class="docutils literal"><span class="pre">Eindex(E)</span></code> is used.</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote>
<div><p>whether the returned COOP is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
<p><strong>isc: array_like, optional</strong></p>
<blockquote class="last">
<div><p>the returned COOP from unit-cell (<code class="docutils literal"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></code>) to
the given supercell, the default is all COOP for the supercell.
To only get unit cell orbital currents, pass <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COOP_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COOP_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">atom_COOP_from_orbital</span></code></a></dt>
<dd>transfer an orbital COOP to atomic COOP</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COOP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COOP"><code class="xref py py-obj docutils literal"><span class="pre">atom_COOP</span></code></a></dt>
<dd>atomic COOP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOOP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOOP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_ACOOP</span></code></a></dt>
<dd>orbital resolved COOP analysis of the spectral function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_ACOOP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_ACOOP"><code class="xref py py-obj docutils literal"><span class="pre">atom_ACOOP</span></code></a></dt>
<dd>atomic COOP analysis of the spectral function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_COHP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_COHP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_COHP</span></code></a></dt>
<dd>orbital resolved COHP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COHP_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COHP_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">atom_COHP_from_orbital</span></code></a></dt>
<dd>atomic COHP analysis from an orbital COHP</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_COHP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_COHP"><code class="xref py py-obj docutils literal"><span class="pre">atom_COHP</span></code></a></dt>
<dd>atomic COHP analysis of the Green function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOHP" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_ACOHP"><code class="xref py py-obj docutils literal"><span class="pre">orbital_ACOHP</span></code></a></dt>
<dd>orbital resolved COHP analysis of the spectral function</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_ACOHP" title="sisl.io.tbtrans.phtncSileTBtrans.atom_ACOHP"><code class="xref py py-obj docutils literal"><span class="pre">atom_ACOHP</span></code></a></dt>
<dd>atomic COHP analysis of the spectral function</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">COOP</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">orbital_COOP</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="c1"># COOP @ E = -1 eV  </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">COOP</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span> <span class="c1"># COOP value between the 11th and 12th orbital </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">COOP</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="n">tbt</span><span class="o">.</span><span class="n">o_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">tbt</span><span class="o">.</span><span class="n">DOS</span><span class="p">(</span><span class="nb">sum</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="n">tbt</span><span class="o">.</span><span class="n">Eindex</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)]</span> 
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.orbital_current">
<code class="descname">orbital_current</code><span class="sig-paren">(</span><em>elec</em>, <em>E</em>, <em>kavg=True</em>, <em>isc=None</em>, <em>only='all'</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_current" title="Permalink to this definition">¶</a></dt>
<dd><p>Orbital current originating from <em class="xref py py-obj">elec</em> as a sparse matrix</p>
<p>This will return a sparse matrix, see <code class="docutils literal"><span class="pre">scipy.sparse.csr_matrix</span></code> for details.
Each matrix element of the sparse matrix corresponds to the orbital indices of the
underlying geometry.</p>
<p>When requesting orbital-currents it is vital to consider how the data needs to be analysed
before extracting the data. For instance, if only local currents are interesting one should
use <code class="docutils literal"><span class="pre">only='+'</span></code>. While if one is interested in the transmission between subset of orbitals,
<code class="docutils literal"><span class="pre">only='all'</span></code> is the correct method.</p>
<p>For inexperienced users it is adviced to try out all three values of <code class="docutils literal"><span class="pre">only</span></code> to ensure
the correct physics is obtained.</p>
<p>This becomes even more important when the orbital currents are calculated with magnetic
fields. With <span class="math">\(\mathbf B\)</span> fields local current loops may form and current does
not necessarily flow along the transport direction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec: str, int</strong></p>
<blockquote>
<div><p>the electrode of originating electrons</p>
</div></blockquote>
<p><strong>E: float or int</strong></p>
<blockquote>
<div><p>the energy or the energy index of the orbital current. If an integer
is passed it is the index, otherwise the index corresponding to
<code class="docutils literal"><span class="pre">Eindex(E)</span></code> is used.</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote>
<div><p>whether the returned orbital current is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
<p><strong>isc: array_like, optional</strong></p>
<blockquote>
<div><p>the returned bond currents from the unit-cell (<code class="docutils literal"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></code>) to
the given supercell, the default is all orbital currents for the supercell.
To only get unit cell orbital currents, pass <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></code>.</p>
</div></blockquote>
<p><strong>only</strong> : {‘all’, ‘+’, ‘-‘}</p>
<blockquote class="last">
<div><p>which orbital currents to return, all, positive or negative values only.
Default to <code class="docutils literal"><span class="pre">'all'</span></code> because it can then be used in the subsequent default
arguments for <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.bond_current_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.bond_current_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">bond_current_from_orbital</span></code></a> and <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_current_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.atom_current_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">atom_current_from_orbital</span></code></a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.bond_current_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.bond_current_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">bond_current_from_orbital</span></code></a></dt>
<dd>transfer the orbital current to bond current</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.bond_current" title="sisl.io.tbtrans.phtncSileTBtrans.bond_current"><code class="xref py py-obj docutils literal"><span class="pre">bond_current</span></code></a></dt>
<dd>the bond current (orbital current summed over orbitals)</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_current_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.atom_current_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">atom_current_from_orbital</span></code></a></dt>
<dd>transfer the orbital current to atomic current</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_current" title="sisl.io.tbtrans.phtncSileTBtrans.atom_current"><code class="xref py py-obj docutils literal"><span class="pre">atom_current</span></code></a></dt>
<dd>the atomic current for each atom (scalar representation of bond-currents)</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.vector_current" title="sisl.io.tbtrans.phtncSileTBtrans.vector_current"><code class="xref py py-obj docutils literal"><span class="pre">vector_current</span></code></a></dt>
<dd>an atomic field current for each atom (Cartesian representation of bond-currents)</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Jij</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">orbital_current</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="c1"># orbital current @ E = -1 eV originating from electrode ``0`` </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Jij</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span> <span class="c1"># orbital current from the 11th to the 12th orbital </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.pivot">
<code class="descname">pivot</code><span class="sig-paren">(</span><em>in_device=False</em>, <em>sort=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.pivot" title="Permalink to this definition">¶</a></dt>
<dd><p>Pivoting orbitals for the full system</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>in_device</strong> : bool, optional</p>
<blockquote>
<div><p>whether the pivoting elements are with respect to the device region</p>
</div></blockquote>
<p><strong>sort</strong> : bool, optional</p>
<blockquote class="last">
<div><p>whether the pivoting elements are sorted</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.read">
<code class="descname">read</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic read method which should be overloaded in child-classes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kwargs :</strong></p>
<blockquote class="last">
<div><p>keyword arguments will try and search for the attribute <code class="docutils literal"><span class="pre">read_&lt;&gt;</span></code>
and call it with the remaining <code class="docutils literal"><span class="pre">**kwargs</span></code> as arguments.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.read_data">
<code class="descname">read_data</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.read_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Read specific type of data.</p>
<p>This is a generic routine for reading different parts of the data-file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>geom: bool, optional</strong></p>
<blockquote>
<div><p>return the geometry</p>
</div></blockquote>
<p><strong>atom_current: bool, optional</strong></p>
<blockquote>
<div><p>return the atomic current flowing through an atom (the <em>activity</em> current)</p>
</div></blockquote>
<p><strong>vector_current: bool, optional</strong></p>
<blockquote class="last">
<div><p>return the orbital currents as vectors</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.read_geometry">
<code class="descname">read_geometry</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.read_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <em class="xref py py-obj">Geometry</em> object from this file</p>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.read_supercell">
<code class="descname">read_supercell</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.read_supercell" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <em class="xref py py-obj">SuperCell</em> object from this file</p>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.shot_noise">
<code class="descname">shot_noise</code><span class="sig-paren">(</span><em>elec_from=0</em>, <em>elec_to=1</em>, <em>classical=False</em>, <em>kavg=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.shot_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Shot-noise term <em class="xref py py-obj">from</em> to <em class="xref py py-obj">to</em> using the k-weights and energy spacings in the file.</p>
<p>Calculates the shot-noise term according to <em class="xref py py-obj">classical</em> (also known as the Poisson value). If <em class="xref py py-obj">classical</em> is True the shot-noise calculated is:</p>
<div class="math">
\[S_P(E, V) = \frac{2e^2}{h}|V|\sum_n T_n(E) = \frac{2e^3}{h}|V|T(E)\]</div>
<p>while for <em class="xref py py-obj">classical</em> False the Fermi-Dirac statistics is taken into account:</p>
<div class="math">
\[S(E, V) = \frac{2e^2}{h}|V|\sum_n T_n(E) (1 - T_n(E))\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec_from: str, int, optional</strong></p>
<blockquote>
<div><p>the originating electrode</p>
</div></blockquote>
<p><strong>elec_to: str, int, optional</strong></p>
<blockquote>
<div><p>the absorbing electrode (different from <em class="xref py py-obj">elec_from</em>)</p>
</div></blockquote>
<p><strong>classical: bool, optional</strong></p>
<blockquote>
<div><p>which shot-noise to calculate</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote>
<div><p>whether the returned shot-noise is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>SislInfo: If *all* of the calculated :math:`T_n(E)` values in the file are above 0.001.</strong></p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.fano" title="sisl.io.tbtrans.phtncSileTBtrans.fano"><code class="xref py py-obj docutils literal"><span class="pre">fano</span></code></a></dt>
<dd>the ratio between the quantum mechanial and the classical shot noise.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.transmission">
<code class="descname">transmission</code><span class="sig-paren">(</span><em>elec_from=0</em>, <em>elec_to=1</em>, <em>kavg=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.transmission" title="Permalink to this definition">¶</a></dt>
<dd><p>Transmission from <em class="xref py py-obj">elec_from</em> to <em class="xref py py-obj">elec_to</em>.</p>
<p>The transmission between two electrodes may be retrieved
from the <em class="xref py py-obj">Sile</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec_from: str, int, optional</strong></p>
<blockquote>
<div><p>the originating electrode</p>
</div></blockquote>
<p><strong>elec_to: str, int, optional</strong></p>
<blockquote>
<div><p>the absorbing electrode (different from <em class="xref py py-obj">elec_from</em>)</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote class="last">
<div><p>whether the returned transmission is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.transmission_eig" title="sisl.io.tbtrans.phtncSileTBtrans.transmission_eig"><code class="xref py py-obj docutils literal"><span class="pre">transmission_eig</span></code></a></dt>
<dd>the transmission decomposed in eigenchannels</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.transmission_bulk" title="sisl.io.tbtrans.phtncSileTBtrans.transmission_bulk"><code class="xref py py-obj docutils literal"><span class="pre">transmission_bulk</span></code></a></dt>
<dd>the total transmission in a periodic lead</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.transmission_bulk">
<code class="descname">transmission_bulk</code><span class="sig-paren">(</span><em>elec=0</em>, <em>kavg=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.transmission_bulk" title="Permalink to this definition">¶</a></dt>
<dd><p>Bulk transmission for the <em class="xref py py-obj">elec</em> electrode</p>
<p>The bulk transmission is equivalent to creating a 2 terminal device with
electrode <em class="xref py py-obj">elec</em> tiled 3 times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec: str, int, optional</strong></p>
<blockquote>
<div><p>the bulk electrode</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote class="last">
<div><p>whether the returned transmission is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.transmission" title="sisl.io.tbtrans.phtncSileTBtrans.transmission"><code class="xref py py-obj docutils literal"><span class="pre">transmission</span></code></a></dt>
<dd>the total transmission</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.transmission_eig" title="sisl.io.tbtrans.phtncSileTBtrans.transmission_eig"><code class="xref py py-obj docutils literal"><span class="pre">transmission_eig</span></code></a></dt>
<dd>the transmission decomposed in eigenchannels</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.transmission_eig">
<code class="descname">transmission_eig</code><span class="sig-paren">(</span><em>elec_from=0</em>, <em>elec_to=1</em>, <em>kavg=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.transmission_eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Transmission eigenvalues from <em class="xref py py-obj">elec_from</em> to <em class="xref py py-obj">elec_to</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec_from: str, int, optional</strong></p>
<blockquote>
<div><p>the originating electrode</p>
</div></blockquote>
<p><strong>elec_to: str, int, optional</strong></p>
<blockquote>
<div><p>the absorbing electrode (different from <em class="xref py py-obj">elec_from</em>)</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote class="last">
<div><p>whether the returned transmission is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.transmission" title="sisl.io.tbtrans.phtncSileTBtrans.transmission"><code class="xref py py-obj docutils literal"><span class="pre">transmission</span></code></a></dt>
<dd>the total transmission</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.transmission_bulk" title="sisl.io.tbtrans.phtncSileTBtrans.transmission_bulk"><code class="xref py py-obj docutils literal"><span class="pre">transmission_bulk</span></code></a></dt>
<dd>the total transmission in a periodic lead</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.vector_current">
<code class="descname">vector_current</code><span class="sig-paren">(</span><em>elec</em>, <em>E</em>, <em>kavg=True</em>, <em>only='+'</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.vector_current" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector for each atom describing the <em>mean</em> path for the current travelling through the atom</p>
<p>See <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.vector_current_from_bond" title="sisl.io.tbtrans.phtncSileTBtrans.vector_current_from_bond"><code class="xref py py-obj docutils literal"><span class="pre">vector_current_from_bond</span></code></a> for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elec: str or int</strong></p>
<blockquote>
<div><p>the electrode of originating electrons</p>
</div></blockquote>
<p><strong>E: float or int</strong></p>
<blockquote>
<div><p>the energy or energy index of the vector current.
Unlike <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_current" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_current"><code class="xref py py-obj docutils literal"><span class="pre">orbital_current</span></code></a> this may not be <em class="xref py py-obj">None</em> as the down-scaling of the
orbital currents may not be equivalent for all energy points.</p>
</div></blockquote>
<p><strong>kavg: bool, int or array_like, optional</strong></p>
<blockquote>
<div><p>whether the returned vector current is k-averaged, an explicit k-point
or a selection of k-points</p>
</div></blockquote>
<p><strong>only</strong> : {‘+’, ‘-‘, ‘all’}</p>
<blockquote>
<div><p>By default only sum <em>outgoing</em> vector currents (<code class="docutils literal"><span class="pre">'+'</span></code>).
The <em>incoming</em> vector currents may be retrieved by <code class="docutils literal"><span class="pre">'-'</span></code>, while the
average incoming and outgoing direction can be obtained with <code class="docutils literal"><span class="pre">'all'</span></code>.
In the last case the vector currents are divided by 2 to ensure the length
of the vector is compatibile with the other options given a pristine system.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>numpy.ndarray</strong> : an array of vectors per atom in the Geometry (only non-zero for device atoms)</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_current" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_current"><code class="xref py py-obj docutils literal"><span class="pre">orbital_current</span></code></a></dt>
<dd>the orbital current between individual orbitals</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.bond_current_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.bond_current_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">bond_current_from_orbital</span></code></a></dt>
<dd>transfer the orbital current to bond current</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.bond_current" title="sisl.io.tbtrans.phtncSileTBtrans.bond_current"><code class="xref py py-obj docutils literal"><span class="pre">bond_current</span></code></a></dt>
<dd>the bond current (orbital current summed over orbitals)</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_current" title="sisl.io.tbtrans.phtncSileTBtrans.atom_current"><code class="xref py py-obj docutils literal"><span class="pre">atom_current</span></code></a></dt>
<dd>the atomic current for each atom (scalar representation of bond-currents)</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.vector_current_from_bond">
<code class="descname">vector_current_from_bond</code><span class="sig-paren">(</span><em>Jab</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.vector_current_from_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector for each atom being the sum of bond-current times the normalized bond between the atoms</p>
<p>The vector current is defined as:</p>
<div class="math">
\[\mathbf J_\alpha = \sum_\beta \frac{r_\beta - r_\alpha}{|r_\beta - r_\alpha|} \cdot J_{\alpha\beta}\]</div>
<p>Where <span class="math">\(J_{\alpha\beta}\)</span> is the bond current between atom <span class="math">\(\alpha\)</span> and <span class="math">\(\beta\)</span> and
<span class="math">\(r_\alpha\)</span> are the atomic coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Jab: scipy.sparse.csr_matrix</strong></p>
<blockquote>
<div><p>the bond currents as retrieved from <a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.bond_current" title="sisl.io.tbtrans.phtncSileTBtrans.bond_current"><code class="xref py py-obj docutils literal"><span class="pre">bond_current</span></code></a></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>numpy.ndarray</strong> : an array of vectors per atom in the Geometry (only non-zero for device atoms)</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.orbital_current" title="sisl.io.tbtrans.phtncSileTBtrans.orbital_current"><code class="xref py py-obj docutils literal"><span class="pre">orbital_current</span></code></a></dt>
<dd>the orbital current between individual orbitals</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.bond_current_from_orbital" title="sisl.io.tbtrans.phtncSileTBtrans.bond_current_from_orbital"><code class="xref py py-obj docutils literal"><span class="pre">bond_current_from_orbital</span></code></a></dt>
<dd>transfer the orbital current to bond current</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.bond_current" title="sisl.io.tbtrans.phtncSileTBtrans.bond_current"><code class="xref py py-obj docutils literal"><span class="pre">bond_current</span></code></a></dt>
<dd>the bond current (orbital current summed over orbitals)</dd>
<dt><a class="reference internal" href="#sisl.io.tbtrans.phtncSileTBtrans.atom_current" title="sisl.io.tbtrans.phtncSileTBtrans.atom_current"><code class="xref py py-obj docutils literal"><span class="pre">atom_current</span></code></a></dt>
<dd>the atomic current for each atom (scalar representation of bond-currents)</dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.wk">
<code class="descname">wk</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.wk" title="Permalink to this definition">¶</a></dt>
<dd><p>Weights of k-points in file</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.wkpt">
<code class="descname">wkpt</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.wkpt" title="Permalink to this definition">¶</a></dt>
<dd><p>Weights of k-points in file</p>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic write method which should be overloaded in child-classes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**kwargs :</strong></p>
<blockquote class="last">
<div><p>keyword arguments will try and search for the attribute <em class="xref py py-obj">write_</em>
and call it with the remaining <code class="docutils literal"><span class="pre">**kwargs</span></code> as arguments.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.write_geometry">
<code class="descname">write_geometry</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.write_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>This is not meant to be used</p>
</dd></dl>

<dl class="method">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.write_tbtav">
<code class="descname">write_tbtav</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.write_tbtav" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert this to a TBT.AV.nc file, i.e. all k dependent quantites are averaged out.</p>
<p>This command will overwrite any previous file with the ending TBT.AV.nc and thus
will not take notice of any older files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>file</strong> : str</p>
<blockquote class="last">
<div><p>output filename</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.xa">
<code class="descname">xa</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.xa" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomic coordinates in file</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.io.tbtrans.phtncSileTBtrans.xyz">
<code class="descname">xyz</code><a class="headerlink" href="#sisl.io.tbtrans.phtncSileTBtrans.xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomic coordinates in file</p>
</dd></dl>

</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="sisl.io.tbtrans.phtsencSileTBtrans.html" class="btn btn-neutral float-right" title="phtsencSileTBtrans" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="sisl.io.tbtrans.tbtavncSileTBtrans.html" class="btn btn-neutral" title="tbtavncSileTBtrans" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2018, Nick R. Papior.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'latest',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>