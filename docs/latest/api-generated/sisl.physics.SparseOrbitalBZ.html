

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>SparseOrbitalBZ &mdash; sisl |release| documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="sisl |release| documentation" href="../index.html"/>
        <link rel="up" title="Physical objects (sisl.physics)" href="sisl.physics.html"/>
        <link rel="next" title="SparseOrbitalBZSpin" href="sisl.physics.SparseOrbitalBZSpin.html"/>
        <link rel="prev" title="Spin" href="sisl.physics.Spin.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> sisl
          

          
          </a>

          
            
            
              <div class="version">
                0.9.2-100
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cite.html">Citing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../other.html">Other resources</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scripts/scripts.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rst/files.html">File formats</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference documentation</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../api.html">API documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="sisl.html">sisl (<code class="docutils literal"><span class="pre">sisl</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.geom.html">Common geometries (<code class="docutils literal"><span class="pre">sisl.geom</span></code>)</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="sisl.physics.html">Physical objects (<code class="docutils literal"><span class="pre">sisl.physics</span></code>)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="sisl.physics.html#brillouin-zone">Brillouin zone</a></li>
<li class="toctree-l3"><a class="reference internal" href="sisl.physics.html#spin-configurations">Spin configurations</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="sisl.physics.html#sparse-matrices">Sparse matrices</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">SparseOrbitalBZ</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.physics.SparseOrbitalBZSpin.html">SparseOrbitalBZSpin</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="sisl.physics.html#physical-quantites">Physical quantites</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="sisl.shape.html">Shapes (<code class="docutils literal"><span class="pre">sisl.shape</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.io.html">Input/Output (<code class="docutils literal"><span class="pre">sisl.io</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.linalg.html">Linear algebra (<code class="docutils literal"><span class="pre">sisl.linalg</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.unit.html">Unit conversion (<code class="docutils literal"><span class="pre">sisl.unit</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="sisl.utils.html">Utility routines (<code class="docutils literal"><span class="pre">sisl.utils</span></code>)</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">sisl</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../api.html">API documentation</a> &raquo;</li>
        
          <li><a href="sisl.physics.html">Physical objects (<code class="docutils literal"><span class="pre">sisl.physics</span></code>)</a> &raquo;</li>
        
      <li>SparseOrbitalBZ</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api-generated/sisl.physics.SparseOrbitalBZ.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="sparseorbitalbz">
<h1>SparseOrbitalBZ<a class="headerlink" href="#sparseorbitalbz" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="sisl.physics.SparseOrbitalBZ">
<em class="property">class </em><code class="descclassname">sisl.physics.</code><code class="descname">SparseOrbitalBZ</code><span class="sig-paren">(</span><em>geom</em>, <em>dim=1</em>, <em>dtype=None</em>, <em>nnzpr=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/sparse.html#SparseOrbitalBZ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse object containing the orbital connections in a Brillouin zone</p>
<p>It contains an intrinsic sparse matrix of the physical elements.</p>
<p>Assigning or changing elements is as easy as with
standard <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/index.html#module-numpy" title="(in NumPy v1.13)"><code class="xref py py-obj docutils literal"><span class="pre">numpy</span></code></a> assignments:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">SparseOrbitalBZ</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span> 
</pre></div>
</div>
<p>which assigns 0.1 as the element between orbital 2 and 3.
(remember that Python is 0-based elements).</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.Rij" title="sisl.physics.SparseOrbitalBZ.Rij"><code class="xref py py-obj docutils literal"><span class="pre">Rij</span></code></a>([what,&nbsp;dtype])</td>
<td>Create a sparse matrix with the vectors between atoms/orbitals</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.Sk" title="sisl.physics.SparseOrbitalBZ.Sk"><code class="xref py py-obj docutils literal"><span class="pre">Sk</span></code></a>([k,&nbsp;dtype,&nbsp;gauge,&nbsp;format])</td>
<td>Setup the overlap matrix for a given k-point</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">__init__</span></code>(geom[,&nbsp;dim,&nbsp;dtype,&nbsp;nnzpr])</td>
<td>Create SparseOrbitalB model from geometry</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.construct" title="sisl.physics.SparseOrbitalBZ.construct"><code class="xref py py-obj docutils literal"><span class="pre">construct</span></code></a>(func[,&nbsp;na_iR,&nbsp;method,&nbsp;eta])</td>
<td>Automatically construct the sparse model based on a function that does the setting up of the elements</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.copy" title="sisl.physics.SparseOrbitalBZ.copy"><code class="xref py py-obj docutils literal"><span class="pre">copy</span></code></a>([dtype])</td>
<td>A copy of this object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.create_construct" title="sisl.physics.SparseOrbitalBZ.create_construct"><code class="xref py py-obj docutils literal"><span class="pre">create_construct</span></code></a>(R,&nbsp;param)</td>
<td>Create a simple function for passing to the <a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.construct" title="sisl.physics.SparseOrbitalBZ.construct"><code class="xref py py-obj docutils literal"><span class="pre">construct</span></code></a> function.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.cut" title="sisl.physics.SparseOrbitalBZ.cut"><code class="xref py py-obj docutils literal"><span class="pre">cut</span></code></a>(seps,&nbsp;axis,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Cuts the sparse orbital model into different parts.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.edges" title="sisl.physics.SparseOrbitalBZ.edges"><code class="xref py py-obj docutils literal"><span class="pre">edges</span></code></a>([atom,&nbsp;exclude,&nbsp;orbital])</td>
<td>Retrieve edges (connections) of a given <em class="xref py py-obj">atom</em> or list of <em class="xref py py-obj">atom</em>’s</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.eigh" title="sisl.physics.SparseOrbitalBZ.eigh"><code class="xref py py-obj docutils literal"><span class="pre">eigh</span></code></a>([k,&nbsp;atoms,&nbsp;gauge,&nbsp;eigvals_only])</td>
<td>Returns the eigenvalues of the physical quantity</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.eigsh" title="sisl.physics.SparseOrbitalBZ.eigsh"><code class="xref py py-obj docutils literal"><span class="pre">eigsh</span></code></a>([k,&nbsp;n,&nbsp;atoms,&nbsp;gauge,&nbsp;eigvals_only])</td>
<td>Calculates a subset of eigenvalues of the physical quantity  (default 10)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.eliminate_zeros" title="sisl.physics.SparseOrbitalBZ.eliminate_zeros"><code class="xref py py-obj docutils literal"><span class="pre">eliminate_zeros</span></code></a>()</td>
<td>Removes all zero elements from the sparse matrix</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.empty" title="sisl.physics.SparseOrbitalBZ.empty"><code class="xref py py-obj docutils literal"><span class="pre">empty</span></code></a>([keep_nnz])</td>
<td>See <em class="xref py py-obj">SparseCSR.empty</em> for details</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.finalize" title="sisl.physics.SparseOrbitalBZ.finalize"><code class="xref py py-obj docutils literal"><span class="pre">finalize</span></code></a>()</td>
<td>Finalizes the model</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.fromsp" title="sisl.physics.SparseOrbitalBZ.fromsp"><code class="xref py py-obj docutils literal"><span class="pre">fromsp</span></code></a>(geom,&nbsp;P[,&nbsp;S])</td>
<td>Read and return the object with possible overlap</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.iter" title="sisl.physics.SparseOrbitalBZ.iter"><code class="xref py py-obj docutils literal"><span class="pre">iter</span></code></a>([local])</td>
<td>Iterations of the orbital space in the geometry, two indices from loop</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.iter_nnz" title="sisl.physics.SparseOrbitalBZ.iter_nnz"><code class="xref py py-obj docutils literal"><span class="pre">iter_nnz</span></code></a>([atom,&nbsp;orbital])</td>
<td>Iterations of the non-zero elements</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.nonzero" title="sisl.physics.SparseOrbitalBZ.nonzero"><code class="xref py py-obj docutils literal"><span class="pre">nonzero</span></code></a>([atom,&nbsp;only_col])</td>
<td>Indices row and column indices where non-zero elements exists</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.remove" title="sisl.physics.SparseOrbitalBZ.remove"><code class="xref py py-obj docutils literal"><span class="pre">remove</span></code></a>(atom)</td>
<td>Create a subset of this sparse matrix by removing the atoms corresponding to <em class="xref py py-obj">atom</em></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.repeat" title="sisl.physics.SparseOrbitalBZ.repeat"><code class="xref py py-obj docutils literal"><span class="pre">repeat</span></code></a>(reps,&nbsp;axis)</td>
<td>Create a repeated sparse orbital object, equivalent to <em class="xref py py-obj">Geometry.repeat</em></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.reset" title="sisl.physics.SparseOrbitalBZ.reset"><code class="xref py py-obj docutils literal"><span class="pre">reset</span></code></a>([dim,&nbsp;dtype,&nbsp;nnzpr])</td>
<td>The sparsity pattern has all elements removed and everything is reset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.rij" title="sisl.physics.SparseOrbitalBZ.rij"><code class="xref py py-obj docutils literal"><span class="pre">rij</span></code></a>([what,&nbsp;dtype])</td>
<td>Create a sparse matrix with the distance between atoms/orbitals</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.set_nsc" title="sisl.physics.SparseOrbitalBZ.set_nsc"><code class="xref py py-obj docutils literal"><span class="pre">set_nsc</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Reset the number of allowed supercells in the sparse orbital</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.spalign" title="sisl.physics.SparseOrbitalBZ.spalign"><code class="xref py py-obj docutils literal"><span class="pre">spalign</span></code></a>(other)</td>
<td>See <em class="xref py py-obj">SparseCSR.align</em> for details</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.spsame" title="sisl.physics.SparseOrbitalBZ.spsame"><code class="xref py py-obj docutils literal"><span class="pre">spsame</span></code></a>(other)</td>
<td>Compare two sparse objects and check whether they have the same entries.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.sub" title="sisl.physics.SparseOrbitalBZ.sub"><code class="xref py py-obj docutils literal"><span class="pre">sub</span></code></a>(atom)</td>
<td>Create a subset of this sparse matrix by only retaining the atoms corresponding to <em class="xref py py-obj">atom</em></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.swap" title="sisl.physics.SparseOrbitalBZ.swap"><code class="xref py py-obj docutils literal"><span class="pre">swap</span></code></a>(a,&nbsp;b)</td>
<td>Swaps atoms in the sparse geometry to obtain a new order of atoms</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.tile" title="sisl.physics.SparseOrbitalBZ.tile"><code class="xref py py-obj docutils literal"><span class="pre">tile</span></code></a>(reps,&nbsp;axis)</td>
<td>Create a tiled sparse orbital object, equivalent to <em class="xref py py-obj">Geometry.tile</em></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.tocsr" title="sisl.physics.SparseOrbitalBZ.tocsr"><code class="xref py py-obj docutils literal"><span class="pre">tocsr</span></code></a>(index[,&nbsp;isc])</td>
<td>Return a <code class="docutils literal"><span class="pre">scipy.sparse.csr_matrix</span></code> of the specified index</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.Rij">
<code class="descname">Rij</code><span class="sig-paren">(</span><em>what=None</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.Rij" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a sparse matrix with the vectors between atoms/orbitals</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>what</strong> : {None, ‘atom’, ‘orbital’}</p>
<blockquote>
<div><p>which kind of sparse vector matrix to return, either an atomic vector matrix
or an orbital vector matrix. The orbital matrix is equivalent to the atomic
one with the same vectors repeated for the same atomic orbitals.
The default is the same type as the parent class.</p>
</div></blockquote>
<p><strong>dtype</strong> : numpy.dtype, optional</p>
<blockquote class="last">
<div><p>the data-type of the sparse matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The returned sparse matrix with vectors are taken from the current sparse pattern.
I.e. a subsequent addition of sparse elements will make them inequivalent.
It is thus important to <em>only</em> create the sparse vector matrix when the sparse
structure is completed.</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.SparseOrbitalBZ.S">
<code class="descname">S</code><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.S" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.Sk">
<code class="descname">Sk</code><span class="sig-paren">(</span><em>k=(0</em>, <em>0</em>, <em>0)</em>, <em>dtype=None</em>, <em>gauge='R'</em>, <em>format='csr'</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/sparse.html#SparseOrbitalBZ.Sk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.Sk" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the overlap matrix for a given k-point</p>
<p>Creation and return of the overlap matrix for a given k-point (default to Gamma).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>k</strong> : array_like, optional</p>
<blockquote>
<div><p>the k-point to setup the overlap at (default Gamma point)</p>
</div></blockquote>
<p><strong>dtype</strong> : numpy.dtype, optional</p>
<blockquote>
<div><p>the data type of the returned matrix. Do NOT request non-complex
data-type for non-Gamma k.
The default data-type is <code class="xref py py-obj docutils literal"><span class="pre">numpy.complex128</span></code></p>
</div></blockquote>
<p><strong>gauge</strong> : {‘R’, ‘r’}</p>
<blockquote>
<div><p>the chosen gauge, <em class="xref py py-obj">R</em> for cell vector gauge, and <em class="xref py py-obj">r</em> for orbital distance
gauge.</p>
</div></blockquote>
<p><strong>format</strong> : {‘csr’, ‘array’, ‘dense’, ‘coo’, …}</p>
<blockquote class="last">
<div><p>the returned format of the matrix, defaulting to the <code class="docutils literal"><span class="pre">scipy.sparse.csr_matrix</span></code>,
however if one always requires operations on dense matrices, one can always
return in <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.13)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.ndarray</span></code></a> (<em class="xref py py-obj">‘array’</em>) or <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.html#numpy.matrix" title="(in NumPy v1.13)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.matrix</span></code></a> (<em class="xref py py-obj">‘dense’</em>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Currently the implemented gauge for the k-point is the cell vector gauge:</p>
<div class="math">
\[S(k) = S_{ij} e^{i k R}\]</div>
<p>where <span class="math">\(R\)</span> is an integer times the cell vector and <span class="math">\(i\)</span>, <span class="math">\(j\)</span> are orbital indices.</p>
<p>Another possible gauge is the orbital distance which can be written as</p>
<div class="math">
\[S(k) = S_{ij} e^{i k r}\]</div>
<p>where <span class="math">\(r\)</span> is the distance between the orbitals <span class="math">\(i\)</span> and <span class="math">\(j\)</span>.
Currently the second gauge is not implemented (yet).</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.construct">
<code class="descname">construct</code><span class="sig-paren">(</span><em>func</em>, <em>na_iR=1000</em>, <em>method='rand'</em>, <em>eta=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.construct" title="Permalink to this definition">¶</a></dt>
<dd><p>Automatically construct the sparse model based on a function that does the setting up of the elements</p>
<p>This may be called in two variants.</p>
<ol class="arabic simple">
<li>Pass a function (<code class="docutils literal"><span class="pre">func</span></code>), see e.g. <code class="docutils literal"><span class="pre">create_construct</span></code>
which does the setting up.</li>
<li>Pass a tuple/list in <code class="docutils literal"><span class="pre">func</span></code> which consists of two
elements, one is <code class="docutils literal"><span class="pre">R</span></code> the radii parameters for
the corresponding parameters.
The second is the parameters
corresponding to the <code class="docutils literal"><span class="pre">R[i]</span></code> elements.
In this second case all atoms must only have
one orbital.</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>func: callable or array_like</strong></p>
<blockquote>
<div><p>this function <em>must</em> take 4 arguments.
1. Is this object (<code class="docutils literal"><span class="pre">self</span></code>)
2. Is the currently examined atom (<code class="docutils literal"><span class="pre">ia</span></code>)
3. Is the currently bounded indices (<code class="docutils literal"><span class="pre">idxs</span></code>)
4. Is the currently bounded indices atomic coordinates (<code class="docutils literal"><span class="pre">idxs_xyz</span></code>)
An example <em class="xref py py-obj">func</em> could be:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">idxs</span><span class="p">,</span> <span class="n">idxs_xyz</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span> 
<span class="gp">... </span>    <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.44</span><span class="p">],</span> <span class="n">idx</span><span class="o">=</span><span class="n">idxs</span><span class="p">,</span> <span class="n">idx_xyz</span><span class="o">=</span><span class="n">idxs_xyz</span><span class="p">)</span> 
<span class="gp">... </span>    <span class="bp">self</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span> 
<span class="gp">... </span>    <span class="bp">self</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.7</span> 
</pre></div>
</div>
</div></blockquote>
<p><strong>na_iR</strong> : int, optional</p>
<blockquote>
<div><p>number of atoms within the sphere for speeding
up the <em class="xref py py-obj">iter_block</em> loop.</p>
</div></blockquote>
<p><strong>method</strong> : {‘rand’, str}</p>
<blockquote>
<div><p>method used in <em class="xref py py-obj">Geometry.iter_block</em>, see there for details</p>
</div></blockquote>
<p><strong>eta: bool, optional</strong></p>
<blockquote class="last">
<div><p>whether an ETA will be printed</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.create_construct" title="sisl.physics.SparseOrbitalBZ.create_construct"><code class="xref py py-obj docutils literal"><span class="pre">create_construct</span></code></a></dt>
<dd>a generic function used to create a generic function which this routine requires</dd>
<dt><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.tile" title="sisl.physics.SparseOrbitalBZ.tile"><code class="xref py py-obj docutils literal"><span class="pre">tile</span></code></a></dt>
<dd>tiling <em>after</em> construct is much faster for very large systems</dd>
<dt><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.repeat" title="sisl.physics.SparseOrbitalBZ.repeat"><code class="xref py py-obj docutils literal"><span class="pre">repeat</span></code></a></dt>
<dd>repeating <em>after</em> construct is much faster for very large systems</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>A copy of this object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dtype</strong> : numpy.dtype, optional</p>
<blockquote class="last">
<div><p>it is possible to convert the data to a different data-type
If not specified, it will use <code class="docutils literal"><span class="pre">self.dtype</span></code></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.create_construct">
<code class="descname">create_construct</code><span class="sig-paren">(</span><em>R</em>, <em>param</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.create_construct" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a simple function for passing to the <a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.construct" title="sisl.physics.SparseOrbitalBZ.construct"><code class="xref py py-obj docutils literal"><span class="pre">construct</span></code></a> function.</p>
<p>This is simply to leviate the creation of simplistic
functions needed for setting up the sparse elements.</p>
<p>Basically this returns a function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">idxs</span><span class="p">,</span> <span class="n">idxs_xyz</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span> 
<span class="gp">... </span>    <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="n">idxs</span><span class="p">)</span> 
<span class="gp">... </span>    <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span> 
<span class="gp">... </span>        <span class="bp">self</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span> 
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>R</strong> : array_like</p>
<blockquote>
<div><p>radii parameters for different shells.
Must have same length as <code class="docutils literal"><span class="pre">param</span></code> or one less.
If one less it will be extended with <code class="docutils literal"><span class="pre">R[0]/100</span></code></p>
</div></blockquote>
<p><strong>param</strong> : array_like</p>
<blockquote class="last">
<div><p>coupling constants corresponding to the <code class="docutils literal"><span class="pre">R</span></code>
ranges. <code class="docutils literal"><span class="pre">param[0,:]</span></code> are the elements
for the all atoms within <code class="docutils literal"><span class="pre">R[0]</span></code> of each atom.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.construct" title="sisl.physics.SparseOrbitalBZ.construct"><code class="xref py py-obj docutils literal"><span class="pre">construct</span></code></a></dt>
<dd>routine to create the sparse matrix from a generic function (as returned from <a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.create_construct" title="sisl.physics.SparseOrbitalBZ.create_construct"><code class="xref py py-obj docutils literal"><span class="pre">create_construct</span></code></a>)</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function only works for geometry sparse matrices (i.e. one
element per atom). If you have more than one element per atom
you have to implement the function your-self.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.cut">
<code class="descname">cut</code><span class="sig-paren">(</span><em>seps</em>, <em>axis</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Cuts the sparse orbital model into different parts.</p>
<p>Recreates a new sparse orbital object with only the cutted
atoms in the structure.</p>
<p>Cutting is the opposite of tiling.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seps</strong> : int</p>
<blockquote>
<div><p>number of times the structure will be cut</p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote class="last">
<div><p>the axis that will be cut</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.SparseOrbitalBZ.dim">
<code class="descname">dim</code><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of components per element</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.SparseOrbitalBZ.dkind">
<code class="descname">dkind</code><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.dkind" title="Permalink to this definition">¶</a></dt>
<dd><p>Data type of sparse elements (in str)</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.SparseOrbitalBZ.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Data type of sparse elements</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.edges">
<code class="descname">edges</code><span class="sig-paren">(</span><em>atom=None</em>, <em>exclude=None</em>, <em>orbital=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve edges (connections) of a given <em class="xref py py-obj">atom</em> or list of <em class="xref py py-obj">atom</em>’s</p>
<p>The returned edges are unique and sorted (see <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.unique.html#numpy.unique" title="(in NumPy v1.13)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.unique</span></code></a>) and are returned
in supercell indices (i.e. <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">edge</span> <span class="pre">&lt;</span> <span class="pre">self.geom.no_s</span></code>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : int or list of int</p>
<blockquote>
<div><p>the edges are returned only for the given atom (but by using  all orbitals of the
requested atom). The returned edges are also atoms.</p>
</div></blockquote>
<p><strong>exclude</strong> : int or list of int, optional</p>
<blockquote>
<div><p>remove edges which are in the <em class="xref py py-obj">exclude</em> list.
Default to <em class="xref py py-obj">atom</em>.</p>
</div></blockquote>
<p><strong>orbital</strong> : int or list of int</p>
<blockquote class="last">
<div><p>the edges are returned only for the given orbital. The returned edges are orbitals.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal"><span class="pre">SparseCSR.edges</span></code></dt>
<dd>the underlying routine used for extracting the edges</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.eigh">
<code class="descname">eigh</code><span class="sig-paren">(</span><em>k=(0</em>, <em>0</em>, <em>0)</em>, <em>atoms=None</em>, <em>gauge='R'</em>, <em>eigvals_only=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/sparse.html#SparseOrbitalBZ.eigh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.eigh" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the eigenvalues of the physical quantity</p>
<p>Setup the system and overlap matrix with respect to
the given k-point, then reduce the space to the specified atoms
and calculate the eigenvalues.</p>
<p>All subsequent arguments gets passed directly to <code class="code docutils literal"><span class="pre">scipy.linalg.eigh</span></code></p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.eigsh">
<code class="descname">eigsh</code><span class="sig-paren">(</span><em>k=(0</em>, <em>0</em>, <em>0)</em>, <em>n=10</em>, <em>atoms=None</em>, <em>gauge='R'</em>, <em>eigvals_only=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/sparse.html#SparseOrbitalBZ.eigsh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.eigsh" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates a subset of eigenvalues of the physical quantity  (default 10)</p>
<p>Setup the quantity and overlap matrix with respect to
the given k-point, then reduce the space to the specified atoms
and calculate a subset of the eigenvalues using the sparse algorithms.</p>
<p>All subsequent arguments gets passed directly to <code class="code docutils literal"><span class="pre">scipy.linalg.eigsh</span></code></p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.eliminate_zeros">
<code class="descname">eliminate_zeros</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.eliminate_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all zero elements from the sparse matrix</p>
<p>This is an <em>in-place</em> operation.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.empty">
<code class="descname">empty</code><span class="sig-paren">(</span><em>keep_nnz=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>See <em class="xref py py-obj">SparseCSR.empty</em> for details</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.finalize">
<code class="descname">finalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.finalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalizes the model</p>
<p>Finalizes the model so that all non-used elements are removed. I.e. this simply reduces the memory requirement for the sparse matrix.</p>
<p>Note that adding more elements to the sparse matrix is more time-consuming than for a non-finalized sparse matrix due to the
internal data-representation.</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.SparseOrbitalBZ.finalized">
<code class="descname">finalized</code><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.finalized" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the contained data is finalized and non-used elements have been removed</p>
</dd></dl>

<dl class="classmethod">
<dt id="sisl.physics.SparseOrbitalBZ.fromsp">
<em class="property">classmethod </em><code class="descname">fromsp</code><span class="sig-paren">(</span><em>geom</em>, <em>P</em>, <em>S=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/sparse.html#SparseOrbitalBZ.fromsp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.fromsp" title="Permalink to this definition">¶</a></dt>
<dd><p>Read and return the object with possible overlap</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.SparseOrbitalBZ.geom">
<code class="descname">geom</code><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.geom" title="Permalink to this definition">¶</a></dt>
<dd><p>Associated geometry</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.SparseOrbitalBZ.geometry">
<code class="descname">geometry</code><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Associated geometry</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.iter">
<code class="descname">iter</code><span class="sig-paren">(</span><em>local=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/sisl/physics/sparse.html#SparseOrbitalBZ.iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterations of the orbital space in the geometry, two indices from loop</p>
<p>An iterator returning the current atomic index and the corresponding
orbital index.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span> 
</pre></div>
</div>
<p>In the above case <a class="reference external" href="https://docs.python.org/dev/library/io.html#module-io" title="(in Python v3.7)"><code class="xref py py-obj docutils literal"><span class="pre">io</span></code></a> always belongs to atom <em class="xref py py-obj">ia</em> and <em class="xref py py-obj">ia</em> may be
repeated according to the number of orbitals associated with
the atom <em class="xref py py-obj">ia</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>local</strong> : bool, optional</p>
<blockquote class="last">
<div><p>whether the orbital index is the global index, or the local index relative to
the atom it resides on.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.iter_nnz">
<code class="descname">iter_nnz</code><span class="sig-paren">(</span><em>atom=None</em>, <em>orbital=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.iter_nnz" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterations of the non-zero elements</p>
<p>An iterator on the sparse matrix with, row and column</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : int or array_like</p>
<blockquote>
<div><p>only loop on the non-zero elements coinciding with the orbitals
on these atoms (not compatible with the <code class="docutils literal"><span class="pre">orbital</span></code> keyword)</p>
</div></blockquote>
<p><strong>orbital</strong> : int or array_like</p>
<blockquote class="last">
<div><p>only loop on the non-zero elements coinciding with the orbital
(not compatible with the <code class="docutils literal"><span class="pre">atom</span></code> keyword)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_nnz</span><span class="p">():</span> 
<span class="gp">... </span>   <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="c1"># is then the non-zero value </span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.SparseOrbitalBZ.nnz">
<code class="descname">nnz</code><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.nnz" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of non-zero elements</p>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.SparseOrbitalBZ.non_orthogonal">
<code class="descname">non_orthogonal</code><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.non_orthogonal" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the object is using a non-orthogonal basis</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.nonzero">
<code class="descname">nonzero</code><span class="sig-paren">(</span><em>atom=None</em>, <em>only_col=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Indices row and column indices where non-zero elements exists</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : int or array_like of int, optional</p>
<blockquote>
<div><p>only return the tuples for the requested atoms, default is all atoms
But for <em>all</em> orbitals.</p>
</div></blockquote>
<p><strong>only_col</strong> : bool, optional</p>
<blockquote class="last">
<div><p>only return then non-zero columns</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal"><span class="pre">SparseCSR.nonzero</span></code></dt>
<dd>the equivalent function call</dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.SparseOrbitalBZ.orthogonal">
<code class="descname">orthogonal</code><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.orthogonal" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the object is using an orthogonal basis</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>atom</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a subset of this sparse matrix by removing the atoms corresponding to <em class="xref py py-obj">atom</em></p>
<p>Indices passed must be unique.</p>
<p>Negative indices are wrapped and thus works.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : array_like of int</p>
<blockquote class="last">
<div><p>indices of removed atoms</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal"><span class="pre">Geometry.remove</span></code></dt>
<dd>equivalent to the resulting <em class="xref py py-obj">Geometry</em> from this routine</dd>
<dt><code class="xref py py-obj docutils literal"><span class="pre">Geometry.sub</span></code></dt>
<dd>the negative of <em class="xref py py-obj">Geometry.remove</em></dd>
<dt><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.sub" title="sisl.physics.SparseOrbitalBZ.sub"><code class="xref py py-obj docutils literal"><span class="pre">sub</span></code></a></dt>
<dd>the negative of <a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.remove" title="sisl.physics.SparseOrbitalBZ.remove"><code class="xref py py-obj docutils literal"><span class="pre">remove</span></code></a>, i.e. retain a subset of atoms</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.repeat">
<code class="descname">repeat</code><span class="sig-paren">(</span><em>reps</em>, <em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a repeated sparse orbital object, equivalent to <em class="xref py py-obj">Geometry.repeat</em></p>
<p>The already existing sparse elements are extrapolated
to the new supercell by repeating them in blocks like the coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reps</strong> : int</p>
<blockquote>
<div><p>number of repetitions along cell-vector <em class="xref py py-obj">axis</em></p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote class="last">
<div><p>0, 1, 2 according to the cell-direction</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal"><span class="pre">Geometry.repeat</span></code></dt>
<dd>the same ordering as the final geometry</dd>
<dt><code class="xref py py-obj docutils literal"><span class="pre">Geometry.tile</span></code></dt>
<dd>a different ordering of the final geometry</dd>
<dt><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.tile" title="sisl.physics.SparseOrbitalBZ.tile"><code class="xref py py-obj docutils literal"><span class="pre">tile</span></code></a></dt>
<dd>a different ordering of the final geometry</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><em>dim=None</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>nnzpr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>The sparsity pattern has all elements removed and everything is reset.</p>
<p>The object will be the same as if it had been
initialized with the same geometry as it were
created with.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dim: int, optional</strong></p>
<blockquote>
<div><p>number of dimensions per element, default to the current number of
elements per matrix element.</p>
</div></blockquote>
<p><strong>dtype: numpy.dtype, optional</strong></p>
<blockquote>
<div><p>the datatype of the sparse elements</p>
</div></blockquote>
<p><strong>nnzpr: int, optional</strong></p>
<blockquote class="last">
<div><p>number of non-zero elements per row</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.rij">
<code class="descname">rij</code><span class="sig-paren">(</span><em>what=None</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.rij" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a sparse matrix with the distance between atoms/orbitals</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>what</strong> : {None, ‘atom’, ‘orbital’}</p>
<blockquote>
<div><p>which kind of sparse distance matrix to return, either an atomic distance matrix
or an orbital distance matrix. The orbital matrix is equivalent to the atomic
one with the same distance repeated for the same atomic orbitals.
The default is the same type as the parent class.</p>
</div></blockquote>
<p><strong>dtype</strong> : numpy.dtype, optional</p>
<blockquote class="last">
<div><p>the data-type of the sparse matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The returned sparse matrix with distances are taken from the current sparse pattern.
I.e. a subsequent addition of sparse elements will make them inequivalent.
It is thus important to <em>only</em> create the sparse distance when the sparse
structure is completed.</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.set_nsc">
<code class="descname">set_nsc</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.set_nsc" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the number of allowed supercells in the sparse orbital</p>
<p>If one reduces the number of supercells <em>any</em> sparse element
that references the supercell will be deleted.</p>
<p>See <em class="xref py py-obj">SuperCell.set_nsc</em> for allowed parameters.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal"><span class="pre">SuperCell.set_nsc</span></code></dt>
<dd>the underlying called method</dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sisl.physics.SparseOrbitalBZ.shape">
<code class="descname">shape</code><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Shape of sparse matrix</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.spalign">
<code class="descname">spalign</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.spalign" title="Permalink to this definition">¶</a></dt>
<dd><p>See <em class="xref py py-obj">SparseCSR.align</em> for details</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.spsame">
<code class="descname">spsame</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.spsame" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two sparse objects and check whether they have the same entries.</p>
<p>This does not necessarily mean that the elements are the same</p>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.sub">
<code class="descname">sub</code><span class="sig-paren">(</span><em>atom</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a subset of this sparse matrix by only retaining the atoms corresponding to <em class="xref py py-obj">atom</em></p>
<p>Indices passed <em>MUST</em> be unique.</p>
<p>Negative indices are wrapped and thus works.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> : array_like of int</p>
<blockquote class="last">
<div><p>indices of retained atoms</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal"><span class="pre">Geometry.remove</span></code></dt>
<dd>the negative of <em class="xref py py-obj">Geometry.remove</em></dd>
<dt><code class="xref py py-obj docutils literal"><span class="pre">Geometry.sub</span></code></dt>
<dd>equivalent to the resulting <em class="xref py py-obj">Geometry</em> from this routine</dd>
<dt><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.remove" title="sisl.physics.SparseOrbitalBZ.remove"><code class="xref py py-obj docutils literal"><span class="pre">remove</span></code></a></dt>
<dd>the negative of <a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.sub" title="sisl.physics.SparseOrbitalBZ.sub"><code class="xref py py-obj docutils literal"><span class="pre">sub</span></code></a>, i.e. remove a subset of atoms</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.swap">
<code class="descname">swap</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Swaps atoms in the sparse geometry to obtain a new order of atoms</p>
<p>This can be used to reorder elements of a geometry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : array_like</p>
<blockquote>
<div><p>the first list of atomic coordinates</p>
</div></blockquote>
<p><strong>b</strong> : array_like</p>
<blockquote class="last">
<div><p>the second list of atomic coordinates</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.tile">
<code class="descname">tile</code><span class="sig-paren">(</span><em>reps</em>, <em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.tile" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a tiled sparse orbital object, equivalent to <em class="xref py py-obj">Geometry.tile</em></p>
<p>The already existing sparse elements are extrapolated
to the new supercell by repeating them in blocks like the coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reps</strong> : int</p>
<blockquote>
<div><p>number of repetitions along cell-vector <em class="xref py py-obj">axis</em></p>
</div></blockquote>
<p><strong>axis</strong> : int</p>
<blockquote class="last">
<div><p>0, 1, 2 according to the cell-direction</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal"><span class="pre">Geometry.tile</span></code></dt>
<dd>the same ordering as the final geometry</dd>
<dt><code class="xref py py-obj docutils literal"><span class="pre">Geometry.repeat</span></code></dt>
<dd>a different ordering of the final geometry</dd>
<dt><a class="reference internal" href="#sisl.physics.SparseOrbitalBZ.repeat" title="sisl.physics.SparseOrbitalBZ.repeat"><code class="xref py py-obj docutils literal"><span class="pre">repeat</span></code></a></dt>
<dd>a different ordering of the final geometry</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="sisl.physics.SparseOrbitalBZ.tocsr">
<code class="descname">tocsr</code><span class="sig-paren">(</span><em>index</em>, <em>isc=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.SparseOrbitalBZ.tocsr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <code class="docutils literal"><span class="pre">scipy.sparse.csr_matrix</span></code> of the specified index</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>index</strong> : int</p>
<blockquote>
<div><p>the index in the sparse matrix (for non-orthogonal cases the last
dimension is the overlap matrix)</p>
</div></blockquote>
<p><strong>isc</strong> : int, optional</p>
<blockquote class="last">
<div><p>the supercell index, or all (if <code class="docutils literal"><span class="pre">isc=None</span></code>)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="sisl.physics.SparseOrbitalBZSpin.html" class="btn btn-neutral float-right" title="SparseOrbitalBZSpin" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="sisl.physics.Spin.html" class="btn btn-neutral" title="Spin" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2017, Nick R. Papior.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.9.2-100',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>